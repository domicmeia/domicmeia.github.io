---
layout: post
category: Note
use_math: true
---

> `OpenGL을 이용한 컴퓨터그래픽스` 정리

2022-1 제주대학교 김수균 교수님의 **컴퓨터 그래픽스** 강의 정리

<details>
<summary>중간고사</summary>
<div markdown="1">

## 컴퓨터 그래픽스 시스템

- 입력 -> Processor(CPU) -> Graphics Processor(GPU) -> Frame Buffer -> 모니터
- **이미지**: 2차원 이미지를 효과적으로 표현
- **모델링**: 가상 3차원 물체를 효과적으로 표현
- **렌더링**: 3차원 모델에서 2차원 이미지로 사진과 같이 사실적으로 표현
- **애니메이션**: 시간에 따른 움직임으로 자연스럽게 표현

## 필셀과 프레임 버퍼

- 래스터 방식: 그래픽스 시스엠 안에서 픽셀의 배열, 즉 래스터로 생성됨
- 각 픽셀은 영상의 한 위치나 작은 영역에 대응
- 픽셀은 Frame Buffer라고 부르는 메모리의 한 부분에 집단으로 저장

## 해상도

- 프레임 버퍼의 픽셀 수가 우리들이 볼 수 있는 영상의 상세함을 결정
- 각 픽셀의 비트 수로 정의되는 프레임 버퍼의 깊이. 즉, 정밀도가 주어진 시스템이 얼마나 많은 색을 표현할 수 있는지 결정함

## 래스터화 혹은 주사변화

- 응용 프로그램에 의하여 픽셀에 관한 정보를 처리하여 프레임 버퍼에 저장시키는 것

## OpenGL의 특징

- 그래픽스 하드웨어에 대한 소프트웨어 인터페이스
- 플랫폼에 독립적
- 다양한 그래픽스 기능을 지원하여 응용 소프트웨어 개발 용이
- OpenGL 가속 하드웨어는 셰이딩 언어를 하드웨어적으로 가속하는 기능 제공

## 그래픽스 파이프라인

- PC 메모리에 있는 프로그램과 데이터
- 그래픽스 파이프라인 구조
  - 정점 처리
  - 클리핑과 기본요소로 조립(선분, 다각형, 곡선과 곡면)
  - 래스터화
  - 단편 처리
- 응용프로그램 -> 정점 처리 -> 클리핑과 기본요소로 조립 -> 래스터화 -> 단편 처리 -> 디스플레이

## 윈도우 GDI

- 그래픽의 출력 담당
- 프린터에 프린트하는 기능도 담당

## 창 800x600변환

```c++
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){
HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, 800, 600, nullptr, nullptr, hInstance, nullptr);
}
```

## 유효화

- 윈도우의 클리아언트 영역을 훼손하면, 윈도우는 WM_PAINT 메시지를 응용 프로그램으로 보냄
- 프로그램은 윈도우에게 그 메시지를 받아서 처리했다는 것을 알려야 함
- 윈도우에게 알리는 과정을 사각형을 유효화 한다고 함

## WM_PAINT

### BeginPaint() ... EndPaint()

- 장점: 자동으로 유효화 수행
- 단점: 무효사각형을 나타내는 rcPaint 속성을 가지고 있으며, 윈도우의 클리핑 영역 외부에는 어떤 것도 그릴 수 없음
  - 그리고 싶다면 rcPaint를 다시 정의해야 함

### GetDC() ... ReleaseDC()

- 장점: 클리핑 사각형을 전체 클라이언트 영역이 됨. 따라서 클라이언트 영역을 그리기 위해 매번 무효 사각형을 정의할 필요가 없음
- 단점: 무효 사각형을 유효화하기 위해 직접 ValidateRect()를 호출
  - 윈도우는 유효화가 이루어지지 않으면 계속 WM_PAINT 메시지를 보냄

## 무효사각형(Invalid Rectangle)

- 다시 그릴 필요가 없는 유일한 영역
- InvalidateRect()함수는 클라이언트 영역의 임의의 부분만 그림

```c++
case WM_SIZE:
        GetClientRect(hWnd, &clientRect);
        Resize(clientRect.right, clientRect.bottom);
        InvalidateRect(hWnd, NULL, false);
        //(무효화할 윈도우 핸들/ 무효화할 사각형 영역 포인터/BeginPaint()를 위해 플래그 지움)

        break;
```

## ValidateRect 역할

- InvalidateRect의 반대
- 무효화된 영역을 유효화시켜 WM_PAINT 메시지가 발생하는 것을 막는데 사용함
- WM_PAINT에서 BeginPaint 함수를 사용하지 않으면 WM_PAINT 메시지가 계속 발생하여 무의미하게 CPU를 사용하는 문제가 발생
  - ValidateRect을 이용해 해결함

## bSetupPixelFormat()

- OpenGL에서 사용하기 위하여 GDI에서 제공하는 화소형식을 적절히 지정해야 함

```c++
bool bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd;
    int pixelformat;

    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.dwLayerMask = PFD_MAIN_PLANE;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cDepthBits = 16;
    pfd.cAccumBits = 0;
    pfd.cStencilBits = 0;

    if ((pixelformat = ChoosePixelFormat(hdc, &pfd)) == 0) {
        MessageBox(NULL, "ChoosePixelFormat() failed!!!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    if (SetPixelFormat(hdc, pixelformat, &pfd) == false) {
        MessageBox(NULL, "SetPixelFormat() failed!!!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    return true;
}
```

## The Window Procedure

```c++
//
//  함수: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  용도: 주 창의 메시지를 처리합니다.
//
//  WM_COMMAND  - 애플리케이션 메뉴를 처리합니다.
//  WM_PAINT    - 주 창을 그립니다.
//  WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT clientRect;
    switch (message)
    {
    case WM_CREATE:
        // Initialize for the OpenGL rendering
        hDeviceContext = GetDC(hWnd);
        if (!bSetupPixelFormat(hDeviceContext)) {
            MessageBox(hWnd, "Error in setting up pixel format for OpenGL", "Error", MB_OK | MB_ICONERROR);
            DestroyWindow(hWnd);
        }
        hRenderingContext = wglCreateContext(hDeviceContext);
        wglMakeCurrent(hDeviceContext, hRenderingContext);
        break;

    case WM_SIZE:
        GetClientRect(hWnd, &clientRect);
        Resize(clientRect.right, clientRect.bottom);
        InvalidateRect(hWnd, NULL, false);

        break;
        /*
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // 메뉴 선택을 구문 분석합니다:
            switch (wmId)
            {
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
        */
    case WM_PAINT:
    {
        DrawScene(hDeviceContext);
        ValidateRect(hWnd, NULL);

        /*
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다...
            EndPaint(hWnd, &ps);
            */
    }
    break;
    case WM_DESTROY:
        // Destroy all about OpenGL
        if (hRenderingContext)
            wglDeleteContext(hRenderingContext);
        if (hDeviceContext)
            ReleaseDC(hWnd, hDeviceContext);
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
```

## 가상 키 사용

```c++
case WM_KEYDOWN:
            switch (wParam)
            {
                case VK_LEFT:
                    // Process the LEFT ARROW key.
                    break;
                case VK_RIGHT:
                    // Process the RIGHT ARROW key.
                    break;
                case VK_UP:
                    // Process the UP ARROW key.
                    break;
                case VK_DOWN:
                    // Process the DOWN ARROW key.
                    break;
                // Process other non-character keystrokes.
                default:
                    break;
            }
```

## 속성

- 기하학적 primitve를 렌더링하는 방법을 결정하는 속성(물체들의 외형)
  - 컬러(points, lines, polygons)
  - 사이즈와 너비(points, lines)
  - 스티플 패턴(lines, polygons)
  - 폴리곤 모드(Polygon mode)

![example](https://math.hws.edu/eck/cs424/notes2013/images/06/gl-primitives.png){:.ioda}

## POLYGON

- Loop로 닫혀 있지만, 내부가 있는 물체

```c++
glColor3f(1.0f, 0.0f, 0.0f);
glBegin(GL_POLYGON);
    glVertex2f(0, 0);
    glVertex2f(0, 100);
    glVertex2f(100, 100);
    glVertex2f(100, 0);
glEnd();
```

## POINTS

```c++
glPointSize(5.0f)
glBegin(GL_POINTS);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(200, 200);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 점 4개 출력
```

## LINES

```c++
glLineWidth(5.0f)
glBegin(GL_LINES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 선 2개 출력
```

## LINE STRIP

```c++
glLineWidth(5.0f)
glBegin(GL_LINE_STRIP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 ㄷ 오른쪽으로 돌린 모양 출력
```

## LINE LOOP

```c++
glLineWidth(5.0f)
glBegin(GL_LINE_LOOP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 ㅁ 출력
```

## LINE STIPPLE

```c++
glEnable(GL_LINE_STIPPLE);
glLineWidth(5.0f)
glLineStipple(3, 0xcccc)
glBegin(GL_LINE_LOOP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd();
glDisable(GL_LINE_STIPPLE) // 펀칭되어있는 ㅁ 출력
```

## 연습문제

```c++
glColor3f(0.0f, 0.0f, 0.0f);
   glLineStipple(3, 0x1C47);
   glLineWidth(5);
      glEnable(GL_LINE_STIPPLE);
      glBegin(GL_LINES);
        glVertex2f(100, 200);
        glVertex2f(200, 200);
      glEnd();
      glDisable(GL_LINE_STIPPLE);
```

## TRIANGLES

```c++
glBegin(GL_TRIANGLES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 삼각형 출력
```

## TRIANGLES STRIP

```c++
glBegin(GL_TRIANGLE_STRIP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 삼각형 2개 출력
```

처음 세 개 정점으로 삼각형을 그린 뒤, 정점이 추가 될 떄마다 삼각형을 직전 두 개 정점과 연결하여 삼각형 추가

## TRIANGLES FAN

```c++
glBegin(GL_TRIANGLE_FAN);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 사각형 출력
```

## Attribute

## OpenGL 카메라

- -z 방향을 가리키는 세계공간의 원점에 카메라를 배치함
- 기본 관측 공간: 한 변의 길이가 2인 원점 중앙에 있는 상자
- 지역좌표(모델좌표): 피사체
- 세계좌표(월드좌표): 무엇을 기준으로 이동, 회전할까
- 쉐이딩: 피사체들이 입거나 가지고 있는 색

```c++
gluLookAt(viewer[0], viewer[1], viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
glRotatef(theta, 1.0f, 0.0f, 0.0f);
///
gluLookAt(2.0, 2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); // 3차원으로 만들어 줌
``
```

## OpenGL에서 초기 카메라

- 객체 프레임의 원점에 놓임
- -z축의 음수방향을 향함
- 직교관측으로 설정됨
- 기본 투영면은 z=0인 면이고, 투영방향은 z축과 나란한다

## 관측(Viewing)

- 투영 행렬에 의해 수행된다.
- 먼저, 행렬 모드를 설정 -> 단위 행렬 -> 투영 행렬
- 관측의 기본 요소
  - 객체: 영상생성 과정이나 관측자와 관계없이 공간에 존재
  - 관측자: 물체의 영상을 형성하는 것
  - 투영선
  - 투영면
- 투영 중심
  - COP가 유한한 경우: 투시 관측
  - COP가 무한한 경우: 평행 관측

## 뷰포트(Viewports)

- 디스플레이 윈도우의 직사각형 영역
- 뷰 사각형과 윈도우 사각형의 종횡비가 일치하지 않아, 왜곡현상 발생 가능

## 종횡비 유지

```c++
void Resize(int width, int height)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glViewport(0, 0, width, height);

    if (width <= height)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glOrtho(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);

    return;

}
```

## 투영

- 3차원 객체가 2차원 객체로 변환되는 과정
- 모델 좌표계, 전역 죄표계, 시점 좌표계를 순차적으로 거친 다각형 정점 좌표를 2차원 투영면에 사상시키는 과정
- 시선: 물체 곳곳을 향함
- 시선: 초점을 향함
- 관찰자 위치: 투영 중심 = 시점 좌표계 원점
- 투시 투영: glFrustum, gluPerspective(시야각 y축)
- 직교 투영: glOrtho
- 축측 세 각이 모두 같으면 등각 투영, 두 각이 같으면 이각 투영, 모두 다르면 삼각 투상

## 클리핑

- 투영은 보이는 범위를 제한하기도 한다. 3차원 공간에 그려진 물체라고 해서 모두 다 보여야 하는 것은 아니며 그 중 필요한 범위를 설정하여 일부만 표시한다. 보이는 영역을 잘라내는 것을 클리핑

## 평행 투영

- 시점이 물체로부터 무한대의 거리에 있다고 간주
  - 투영선이 평행
  - 원래 물체의 평행선은 투영 후에도 평행
  - 시점과의 거리에 무관하게 같은 길이의 물체는 같은 길이로 투영

## 직교 투영

- 투영선이 반드시 투영면과 직교

```c++
glMatrixMode(GL_PROJECTION);
glLoadIdentity( );
glOrtho(left, right, bottom, top, near, far);
// near < far, 양수 음수 모두 가능
```

```c++
if (width <= height)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glOrtho(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);
```

## 다중 관측 직교 투영

- 여러 개의 투영면을 만드는데, 각각은 객체의 주면 중 하나와 평행하다.
- 일반적으로 세 개의 관측(전면, 상면, 우측면 등)을 표시한다.
- 거리와 각이 모두 보존되고 거리와 모양의 왜곡이 없음

## 축측 투영

- 투영선은 투영면에 수직이지만, 투영면은 객체에 대한 어떠한 방향에도 존재할 수 있다.
  - **등축 투영**: 만일 투영면이 삼각형 객체의 모서리에서 만나는 세 개의 주면에 대해서 대칭으로 놓여짐
  - **이축 투영**: 투영면이 두 개의 주면이 대칭되도록 놓여짐
  - **삼축 투영**: 일반적인 경우

## 경사 투영

- 투영면에 평행한 면들에 대해서만 각이 유지됨

## 투시 투영

- 투영면에서 멀리 떨어져 있는 객체는 작게, 가까운 거리에 있는 객체는 상대적으로 크게 투영
  - 시점이 물체로부터 유한한 거리가에 있다고 간주
  - 투영선이 시점에서 출발하여 방사선 모양으로 퍼져감
  - 카메라나 사람의 눈이 물체를 포착하는 방법

```c++
glMatrixMode(GL_PROJECTION);
glLoadIdentity( );
glFrustum(left, right, bottom, top, near, far);
// near과 far은 항상 양수!!
```

```c++
if (width <= height)
        glFrustum(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glFrustum(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);
```

```c++
glMatrixMode(GL_PROJECTION);
glLoadIdentity( );
gluPerspective(fovy, aspect, near, far);
// fovy: y축 방향으로 시야각
// 종횡비 = width / height
```

```c++
gluPerspective(90, (GLdouble)width / (GLdouble)height, 1.0, 10.0);
```

## 원근감

- 동일한 크기의 물체라도 시점으로부터 멀리 있는 것은 작게 보이고 가까운 것은 크게 보임
- 일점, 이점, 삼점 투시 관측의 차이는 객체의 세가지 주 방향 가운데 얼마나 많은 방향이 투영면에 평행한 가에 있음
- 삼점 투시의 겨웅 세 개의 주 방향에 평행한 모든 직선들은 세 개의 소실점에서 만남

## 소실점

- 투시 투영 결과 평행선이 만나는 점

## 투시투영변환

- 직선->직선 / 평면->평면
- 물체 정점간의 거리에 대한 축소율이 달라짐

## 등축

- 3차원 물체를 평면 상에 표현하기 위한 방법의 일종으로 x, y, z세 좌표푹이 서로 이루는 각도가 모두 같거나 120도를 이루는 특성

## 시야각

- 카메라의 시야각 안에 들어오는 물체만 이미지로 나타남

## 뷰 볼륨

- 장면으로 잘라내는 공간
- frustum - 잘려진 피라미드

## 그림자 폴리곤

- 과정을 (x1, y1, z1)에 위치
- (-x1, -y1, -z1)만큼 평행 이동
- 원점 중심으로 투시 투영
- 다시 (x1, y1, z1)만큼 평행 이동

```c++
//shadow Polygon 변수 추가
GLfloat light_pos[3] = { -1.0f, 10.0f, -1.0f };
void Quad_NC(int a, int b, int c, int d);
```

```c++
GLfloat m[16];
    for (int i = 0; i < 16; i++) m[i] = 0.0f;
    m[0] = m[5] = m[10] = 1.0f;
    m[7] = -1.0f / light_pos[1];

    glPushMatrix();
    glTranslatef(0.0f, -1.5f, 0.0f);
    glTranslatef(light_pos[0], light_pos[1], light_pos[2]);
    glMultMatrixf(m);
    glTranslatef(-light_pos[0], -light_pos[1], -light_pos[2]);


    glColor3f(0.5f, 0.5f, 0.5f);
    glBegin(GL_QUADS);
    Quad_NC(0, 3, 2, 1);
    Quad_NC(1, 2, 6, 5);
    Quad_NC(2, 3, 7, 6);
    Quad_NC(3, 0, 4, 7);
    Quad_NC(4, 5, 6, 7);
    Quad_NC(5, 4, 0, 1);
    glEnd();
    glPopMatrix();
```

</div>
</details>

<details>
<summary>기말고사</summary>
<div markdown="1">

## Basic Elements

보다 정교한 물체를 만들 수 이쓴 최소 기본 요소 조합

- Points : 공간에서의 위치
- Scalars : 두 점 사이의 거리를 측정
- Vectors : 크기와 방향이 있는 모든 양

## 변환

한 점 또는 벡터를 다른 점 또는 벡터로 매핑 시키는 것

## 이동

객체를 구성하는 각 점을 동일한 양만큼 이동

## 회전

주어진 회전축과 기준점에 대해 반시계 방향으로 회전

## 신축(확대/축소)

원점을 기준으로 크기 인자만큼 물체의 크기를 늘이거나 또는 줄임

- uniform : 각 축 방향으로 동일한 비율로 신축
- 필요한 요소: 기준점, 방향, 크기
- 반사: 신축의 크기가 음수

## Affine
- 아핀 변환(Affine Transformation)이란 점, 직선, 평면, 평행선을 보존하는 변환
- 동차 좌표계(Homogeneous Coordinates)를 사용하면 아핀 변환을 하나의 행렬곱으로 나타 낼 수 있다.
- 동차 좌표계(x, y, z,ω)에서 ω값으로 점은 1 벡터는 0이다.

## 좌표계

- 직교 좌표계 : 2차원에서 어떤 위치를 나타낼 때 사용 -> 회전 표시 안됨
- 극좌표계 : 2차원에서 임의의 점을 r과 θ 로 표시 (r, θ)
  - 각도: 동일한 기점을 갖는 두 개의 반직선이 벌어지는 정도
  - 라디안: 점선으로 나타낸 두 반직선 사이의 곡선 부분의 길이는 두 반직선 사이를 라디안으로 나타낸 각도임
  - 회전의 필요한 요소
    - 기준점(고정점): 회전에 의해 위치가 변하지 않는 점
    - 회전각 : 양수(오른손 좌표계에서는 반시계 방향)
    - 3D에서 회전축 : 회전에 의해 축 위에 있는 점들의 위치는 변하지 않음
- 등차좌표계
  - frame : 기저벡터와 참조점(원점)을 포함하는 것
  - Homogeneous coordinates
    - Hardware pipeline은 4차원 표현으로 작동함
    - For orthographic viewing, 벡터에 대해 w=0을 유지하고, 점에 대해 w=1을 유지함
    - For perspective viewing, 투시 분활이 필요함

## OpenGL에서 변환 행렬

- CTM : 모든 꼭지점에 적용될 행렬
  - 렌더링 파이프라인의 일부
  - 행렬 모드: Model-view와 projection 행렬
    ![same](./image/same.jpg)

## OpenGL에서 변환 행렬 - 예제

- 필요한 요소
  - 기준점: (4,5,6)
  - 회전 각: 45도
  - 회전축: 원점에서 점(1,2,3)을 지나는 벡터

```c++
glMatrixMode(GL_MODELVIWE);
glLoadIdentity( );
glTranslatef(4.0, 5.0, 6.0);
glRotatef(45.0, 1.0, 2.0, 3.0);
glTranslatef(-4.0, -5.0, -6.0);
```

<details>
<summary>더보기</summary>
<div markdown="1">

```c++
float theta[3] = { 0.0f, 0.0f, 0.0f };
int axis = 1;
void display(void){
    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glRotatef(theta[0], 1.0, 0.0, 0.0);
    glRotatef(theta[1], 0.0, 1.0, 0.0);
    glRotatef(theta[2], 0.0, 0.0, 1.0);
    colorcube();
    SwapBuffers();
}
```

</div>
</details>

## 사원수

애니메이션의 부드러운 회전을 구현하기 위해 오힐러 회전 행렬을 대신 사용되는 복소수로서, 하나의 실수부와 세 개의 허수부를 갖는 수를 무엇이라 부르는가

## 사원수와 3D 회전

- 문제점
  - 3차원에서는 원점을 중심으로 회전을 지정하기 위해서는 벡터값인 회전축 방향과 스칼라 값인 회전각 모두를 지정해야하기 때문에 매우 복잡함
- 해결책 : 사원수를 이용해서 해결 가능

## 로봇팔 예제

<details>
<summary>시험에 안나옴</summary>
<div markdown="1">

```c++
void DrawScene(HDC MyDC)
{
    glEnable(GL_DEPTH_TEST);

    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    gluLookAt(2.0f, 2.0f, 2.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);

    //행렬 직접 설정 ------------
    // math.h 헤더 사용
    //GLfloat m[16];
    //for (int i = 0; i < 16; i++) m[i] = 0.0f;
    //m[0] = m[5] = m[10] = m[15] = 1.0f;
    //m[4] = 1.0f / tanf(60 / 180.f * 3.14159265);
    //glMultMatrixf(m);
    //------------------------------
    //glPushMatrix();
    //glTranslatef(0.0f, -1.0f, 0.0f);
    //
    //glColor3f(1.0f, 0.0f, 0.0f);
    //glutWireTetrahedron();
    //glPopMatrix();
    //glTranslatef(0.0f, 1.0f, 0.0f);
    //
    //glColor3f(0.0f, 1.0f, 0.0f);
    //glutWireCube(0.5);

    //회전을 위해 glRotatef을 추가, 팔 각각에 모두 추가
    glTranslatef(0.0f, -1.0f, 0.0f);
    glRotatef(baseAngle, 0.0f, 1.0f, 0.0f);
    BaseArm();
    glRotatef(lowAngle, 0.0f, 0.0f, 1.0f);
    glTranslatef(0.0f, 0.4f, 0.0f);

    LowerArm();
    glTranslatef(0.0f, 1.0f, 0.0f);
    glRotatef(upperAngle, 1.0f, 0.0f, 0.0f);

    UpperArm();
    SwapBuffers(MyDC);
    return;
}

void BaseArm(void)
{
    glPushMatrix();
    glColor3f(1.0f, 0.0f, 0.0f);
    glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);
    gluCylinder(p0bj, 0.5, 0.5, 0.3, 20, 1);
    glPopMatrix();

    return;
}

void LowerArm(void)
{
    glPushMatrix();
    glColor3f(0.0f, 1.0f, 0.0f);
    glTranslatef(0.0f, 0.5f, 0.0f);
    glScalef(0.2f, 1.0f, 0.2f);
    glutWireCube(1.0);
    glPopMatrix();

    return;
}

void UpperArm(void)
{
    glPushMatrix();
    glColor3f(0.0f, 0.0f, 1.0f);
    glTranslatef(0.0f, 0.4f, 0.0f);
    glScalef(0.2f, 0.8f, 0.2f);
    glutWireCube(1.0);
    glPopMatrix();

    return;
}
```

</div>
</details>

## GL의 모델변환

- 후위 곱셈
  - 세계 좌표계를 기준으로 하는 모델 좌표계의 변환

## glPushMatrix() and glPopMatrix()

변환 수행 후 실행 전과 동일한 상태로 복귀

## 렌더링

- 각 필셀에 채워질 색상을 정하는 과정
- 빛과 반사되는 면 사이에 발생하는 여러 종류의 상호작용에 의해 색상 결정

## 음영 = 그늘

## 조명의 종류

- 주변광 : 균일하게 비추어지는 조명
  - 과정이 반복되면서 광원의 위치 및 수와는 상관없이 어느 정도 균일한 조명이 됨
  - 주변 조명에 의한 산란 반사
- 점 광원 : 모든 방향으로 동일한 양의 빛을 방출
  - GL_CONSTANT_ATTENUATION (default: 1)
  - GL_LINEAR_ATTENUATION (default: 0)
  - GL_QUADRATIC_ATTENUATION (default: 0)
- 원거리 광원 방향성광원 : 무한한 거리이ㅔ 있는 점 광원 -> 벡터가 변하지 않음
  - 거리에 따른 감쇄 현상 없음
  - GL_POSITION, GL_DIFFUSE, GL_SPECULAR, GL_AMBIENT
- 스포트 광원 : 방향과 범위 각을 갖는 점 광원
  - 감쇄현상, 중앙에 집중되고 주변으로 갈수록 줄어듦
  - GL_SPOT_DIRECTION, GL_SPOT_CUTOFF, GL_SPOT_EXPONENT
- Glfloat position(x, y, z, a)
  - a = 0 : 무한대의 위치에 놓음
  - a = 1 : 지정된 좌표에 위치

## 표면의 성질

- 산란반사 : 반사되는 빛을 모든 방향으로 보냄
  - 빛의 반사량: 입사 광선의 각도에 따라 달라짐, 코사인 법칙
- 거울반사 : 반사되는 빛을 일정 방향의 범위 각 안으로 보냄

  - 빛의 반사량 : 입사 광선과 시점(카메라) 사이의 각에 따라 달라짐
    ![spec](./image/spec.jpg)
  - Phong model: Shininess 계수
    - 100 < < 200 : 광택이 많은 표면
    - 1 ≤ < 100 : 광택이 없는 표면

- 투과: 굴절
  ![refl](./image/refl.jpg)

## 렌더링 방정식
![ran](./image/ran.jpg)

..? 천천히 생각해보자
광원에서 나온 빛은 다양한 방향으로 표면에 도착해서 반사, 투과, 굴절 등을 할 것이고
반사된 빛 중 일부만이 카메라(viewer)에 잡힐 것이다. 표면의 광택감은 빛의 행로에 큰 영향을 끼치는데, 우리는 이 광택의 정도를 Shininess 계수라 한다. 이 값은 그림에서 알파로 표현되었다. 이 값은 작을 수록 표면에 광택이 없고 눈이 부시게 된다.
우리는 카메라에 잡히는 빛이 카메라로 향하는 빛인 점을 알 수 있다.

## 예제

<details>
<summary>시험에 안나옴</summary>
<div markdown="1">

```c++
void DrawScene(HDC MyDC)
{
    glEnable(GL_DEPTH_TEST);

    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    gluLookAt(2.0f, 2.0f, 2.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    //GLfloat position0[] = { 2.0f, 0.0f, 0.0f, 1.0f };
    //GLfloat diffuse0[] = { 1.0f, 0.0f, 0.0f, 1.0f };
    //GLfloat specular0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    //GLfloat ambient0[] = { 0.1f, 0.1f, 0.1f, 0.1f };
    //
    //glLightfv(GL_LIGHT0, GL_POSITION, position0);
    //glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);
    //glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);
    //glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);
    //
    ////감쇄현상
    ////glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0f);
    ////glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.2f);
    ////glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.1f);
    //
    ////스포트라이트
    //GLfloat direction0[] = { -1.0f, 0.5f, 0.0f };
    //glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, direction0);
    //glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, 30.0f);
    //glLightf(GL_LIGHT0, GL_SPOT_EXPONENT, 20.0f);
    //
    ////조명 추가
    //glEnable(GL_LIGHT1);
    //
    //GLfloat position1[] = { 0.0f, 1.0f, 0.0f, 0.0f };
    //GLfloat diffuse1[] = { 0.0f, 0.0f, 1.0f, 1.0f }; //난반사
    //GLfloat specular1[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    //GLfloat ambient1[] = { 0.1f, 0.1f, 0.1f, 0.1f };
    //
    //glLightfv(GL_LIGHT1, GL_POSITION, position1);
    //glLightfv(GL_LIGHT1, GL_DIFFUSE, diffuse1);
    //glLightfv(GL_LIGHT1, GL_SPECULAR, specular1);
    //glLightfv(GL_LIGHT1, GL_AMBIENT, ambient1);
    //
    //glMultMatrixd(trball.rMat);
    //
    //glColor3f(1.0f, 0.0f, 0.0f);
    ////glutWireTeapot(1.0);
    //glutSolidTeapot(1.0);

    if (PS) {
        DireactionalLight(PS);
    }
    else if (DS) {
        PointLight(DS);
    }
    else if (SS) {
        SpotLight(SS);
    }
    else if (MS) {
        MultipleLight(MS);
    }
    glMultMatrixd(trball.rMat);
    glColor3f(1.0f, 0.0f, 0.0f);
    glutSolidTeapot(1.0);
    // glutWireTeapot(1.0);


    SwapBuffers(MyDC);

    return;
}
void DireactionalLight(bool DS)
{
    if (DS)
    {
        GLfloat position0[] = { 0.0f, 1.0f, 0.0f, 0.0f };
        GLfloat diffuse0[] = { 0.0f, 0.0f, 1.0f, 1.0f };
        GLfloat specular0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat ambient0[] = { 0.1f, 0.1f, 0.1f, 0.1f };

        glLightfv(GL_LIGHT0, GL_POSITION, position0);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);
    }
}
void PointLight(bool PS)
{
    if (PS)
    {
        GLfloat position0[] = { 2.0f, 0.0f, 0.0f, 1.0f };
        GLfloat diffuse0[] = { 1.0f, 0.0f, 0.0f, 1.0f };
        GLfloat specular0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat ambient0[] = { 0.1f, 0.1f, 0.1f, 0.1f };

        glLightfv(GL_LIGHT0, GL_POSITION, position0);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);

        glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 2.0f);
        glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.2f);
        glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.1f);
    }

}
void SpotLight(bool SS)
{
    if (SS)
    {
        GLfloat position0[] = { 0.0f, 0.0f, 2.0f, 1.0f };
        GLfloat diffuse0[] = { 0.0f, 1.0f, 0.0f, 1.0f };
        GLfloat specular0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat ambient0[] = { 0.1f, 0.1f, 0.1f, 0.1f };

        glLightfv(GL_LIGHT0, GL_POSITION, position0);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);

        GLfloat directional0[] = { 0.0f, 0.0f, -1.0f };
        glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, directional0);
        glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, 30.0f);
        glLightf(GL_LIGHT0, GL_SPOT_EXPONENT, 10.0f);
    }

}
void MultipleLight(bool MS) {

    if (MS)
    {
        glEnable(GL_LIGHT1);
        glEnable(GL_LIGHT2);
        GLfloat position0[] = { 0.0f, 1.0f, 0.0f, 0.0f };
        GLfloat diffuse0[] = { 0.0f, 0.0f, 1.0f, 1.0f };
        GLfloat specular0[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat ambient0[] = { 0.1f, 0.1f, 0.1f, 0.1f };

        glLightfv(GL_LIGHT0, GL_POSITION, position0);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);
        glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);

        GLfloat position1[] = { 2.0f, 0.0f, 0.0f, 1.0f };
        GLfloat diffuse1[] = { 1.0f, 0.0f, 0.0f, 1.0f };
        GLfloat specular1[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat ambient1[] = { 0.1f, 0.1f, 0.1f, 0.1f };

        glLightfv(GL_LIGHT1, GL_POSITION, position1);
        glLightfv(GL_LIGHT1, GL_DIFFUSE, diffuse1);
        glLightfv(GL_LIGHT1, GL_SPECULAR, specular1);
        glLightfv(GL_LIGHT1, GL_AMBIENT, ambient1);

        glLightf(GL_LIGHT1, GL_CONSTANT_ATTENUATION, 2.0f);
        glLightf(GL_LIGHT1, GL_LINEAR_ATTENUATION, 0.2f);
        glLightf(GL_LIGHT1, GL_QUADRATIC_ATTENUATION, 0.1f);

        GLfloat position2[] = { 0.0f, 0.0f, 2.0f, 1.0f };
        GLfloat diffuse2[] = { 0.0f, 1.0f, 0.0f, 1.0f };
        GLfloat specular2[] = { 1.0f, 1.0f, 1.0f, 1.0f };
        GLfloat ambient2[] = { 0.1f, 0.1f, 0.1f, 0.1f };

        glLightfv(GL_LIGHT2, GL_POSITION, position2);
        glLightfv(GL_LIGHT2, GL_DIFFUSE, diffuse2);
        glLightfv(GL_LIGHT2, GL_SPECULAR, specular2);
        glLightfv(GL_LIGHT2, GL_AMBIENT, ambient2);

        GLfloat directional0[] = { 0.0f, 0.0f, -1.0f };
        glLightfv(GL_LIGHT2, GL_SPOT_DIRECTION, directional0);
        glLightf(GL_LIGHT2, GL_SPOT_CUTOFF, 30.0f);
        glLightf(GL_LIGHT2, GL_SPOT_EXPONENT, 20.0f);
    }

}

```
</div>
</details>

## 표면 렌더링

- 각 픽셀에 채워진 색상을 정하는 과정
- 지역적 렌더링, 전역적 렌더링

## 다각형 쉐이딩 기법

- 다각형 메쉬의 각 면을 렌더링
- 균일 쉐이딩, 그로우 쉐이딩, 퐁 쉐이딩

## 텍셀

텍스처 이미지는 프로세서 메모리에 배열로 저장될 때 그 배여의 요소

## 균일 쉐이딩

- 균일 쉐이딩 된 물체들은 다각형으로 구성된 것처럼 보임
- 각 면에 대해 한 번의 렌더링 방정식 계산
- 인간의 시각 시스템
  - 측면 금제
    - 망막의 신경 세포가 주위를 억제시키는 현상
    - 빛의 세기의 차이에 매우 예민함
  - 마하 밴드
    - 경계선 영역은 실제보다 더 밝게 인식됨
  - 이러한 현상을 피하기 위해 부드러운 쉐이딩 기술 필요

## 그로우 쉐이딩

- 각 꼭지점에 대해 한 번의 렌더링 방정식 계산 -> 선형 보간법
- 꼭지점의 법선 벡터 -> 이웃 면들의 법선 벡터의 평균
- 다각형 메쉬가 부드럽게 렌더링 됨

## 환경 매핑

렌더링 되고자 하는 객체의 주변 영상들을 텍스처로 매핑시킴으로써 표면에 주변을 반사하는 정반사의 특징을 잘 표현할 수 있는 텍스처 매핑 기술

## 범프 매핑

렌더링될 물체의 픽셀마다 표면 법선을 흔들어 높낮이가 있어 보이게 하는 컴퓨터 그래픽 기술 중 하나. 그 결과는 실제 물체의 표면과 매우 비슷해 보임

![shading](./image/shading.jpg)

## 퐁 쉐이딩

- 각 픽셀에 대해 한 번의 렌더링 방정식 계산 -> off-line
- 다각형 내의 한 점에서의 법선 벡터 계산

## 전역적 렌더링

- 전역 조명 모델 : 다른 물체면에서 반사되어 입사되는 빛까지 고려한 조명 모델
  - 전역적 효과
    - 그림자
    - 굴절
    - 물체 사이의 반사
  - 기법
    - 광선 추적법
- 지역 조명 모델 : 광원으로부터 직접 물체면으로 입사되는 빛 만을 고려한 모델
  - 지역적 조명 모델의 단점
    - 다른 물체의 의해 광원의 일부가 가려지는 현상을 표현 못함
    - 다른 물체들로부터 반사되어 받는 빛을 표현 못함

## 그림자

광원이 가려진 현상

## 광선 추적 트리

- 조명 계산을 이진 트리로 표현
  - 한쪽 가지 -> 반사
  - 다른 쪽 가지 -> 투과
  - 종료 -> 최대 값에 도달하거나 광원에 만나는 경우
- 픽셀 강도
  - 루트 노드에서 계산한 모든 강도들의 합
  - leaf 노드로부터 출발
  - 어떤 표면과도 교차하지 않는 경우, 배경의 강도를 취함

## Radiosity

- 목표
  - 물체 사이의 산란 반사와 그림자를 시뮬레이션
  - 건축물이나 실내 인테리어에 적합한 렌더링 방법
  - 모든 다각형을 광원으로 취급
- 장점
  - 그림자와 간접적인 산란 조명 효과를 물리적으로 잘 모델링 함
  - 시점에 독립적임 -> 시점이 변함에 따라 재계산 필요 없음

  ## 쉐이딩 예제
  자세한 것은 생략
  ```c++
  //조명 키기
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    //만약 RGB값이 나온다면 GL_AMBIENT 생각하기
    //fv와 f 구별하기
  ```

</div>
</details>
