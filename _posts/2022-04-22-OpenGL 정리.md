---
layout: post
category: Note
---
> `OpenGL을 이용한 컴퓨터그래픽스` 정리

<details>
<summary>중간고사</summary>
<div markdown="1">

## 컴퓨터 그래픽스 시스템
- 입력 -> Processor(CPU) -> Graphics Processor(GPU) -> Frame Buffer -> 모니터
- **이미지**: 2차원 이미지를 효과적으로 표현
- **모델링**: 가상 3차원 물체를 효과적으로 표현
- **렌더링**: 3차원 모델에서 2차원 이미지로 사진과 같이 사실적으로 표현
- **애니메이션**: 시간에 따른 움직임으로 자연스럽게 표현

## 필셀과 프레임 버퍼
- 래스터 방식: 그래픽스 시스엠 안에서 픽셀의 배열, 즉 래스터로 생성됨
- 각 픽셀은 영상의 한 위치나 작은 영역에 대응
- 픽셀은 Frame Buffer라고 부르는 메모리의 한 부분에 집단으로 저장

## 해상도
- 프레임 버퍼의 픽셀 수가 우리들이 볼 수 있는 영상의 상세함을 결정
- 각 픽셀의 비트 수로 정의되는 프레임 버퍼의 깊이. 즉, 정밀도가 주어진 시스템이 얼마나 많은 색을 표현할 수 있는지 결정함

## 래스터화 혹은 주사변화
- 응용 프로그램에 의하여 픽셀에 관한 정보를 처리하여 프레임 버퍼에 저장시키는 것

## OpenGL의 특징
- 그래픽스 하드웨어에 대한 소프트웨어 인터페이스
- 플랫폼에 독립적
- 다양한 그래픽스 기능을 지원하여 응용 소프트웨어 개발 용이
- OpenGL 가속 하드웨어는 셰이딩 언어를 하드웨어적으로 가속하는 기능 제공

## 그래픽스 파이프라인
- PC 메모리에 있는 프로그램과 데이터
- 그래픽스 파이프라인 구조
   - 정점 처리
   - 클리핑과 기본요소로 조립(선분, 다각형, 곡선과 곡면)
   - 래스터화
   - 단편 처리
- 응용프로그램 -> 정점 처리 -> 클리핑과 기본요소로 조립 -> 래스터화 -> 단편 처리 -> 디스플레이

## 윈도우 GDI
- 그래픽의 출력 담당
- 프린터에 프린트하는 기능도 담당

## 창 800x600변환
```c++
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){
HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, 800, 600, nullptr, nullptr, hInstance, nullptr);
}
```

## 유효화
- 윈도우의 클리아언트 영역을 훼손하면, 윈도우는 WM_PAINT 메시지를 응용 프로그램으로 보냄
- 프로그램은 윈도우에게 그 메시지를 받아서 처리했다는 것을 알려야 함
- 윈도우에게 알리는 과정을 사각형을 유효화 한다고 함

## WM_PAINT

### BeginPaint() ... EndPaint()
- 장점: 자동으로 유효화 수행
- 단점: 무효사각형을 나타내는 rcPaint 속성을 가지고 있으며, 윈도우의 클리핑 영역 외부에는 어떤 것도 그릴 수 없음
   - 그리고 싶다면 rcPaint를 다시 정의해야 함

### GetDC() ... ReleaseDC()
- 장점: 클리핑 사각형을 전체 클라이언트 영역이 됨. 따라서 클라이언트 영역을 그리기 위해 매번 무효 사각형을 정의할 필요가 없음
- 단점: 무효 사각형을 유효화하기 위해 직접 ValidateRect()를 호출
     - 윈도우는 유효화가 이루어지지 않으면 계속 WM_PAINT 메시지를 보냄

## 무효사각형(Invalid Rectangle)
- 다시 그릴 필요가 없는 유일한 영역
- InvalidateRect()함수는 클라이언트 영역의 임의의 부분만 그림

```c++
case WM_SIZE:
        GetClientRect(hWnd, &clientRect);
        Resize(clientRect.right, clientRect.bottom);
        InvalidateRect(hWnd, NULL, false);
        //(무효화할 윈도우 핸들/ 무효화할 사각형 영역 포인터/BeginPaint()를 위해 플래그 지움)

        break;
```

## ValidateRect 역할
- InvalidateRect의 반대
- 무효화된 영역을 유효화시켜 WM_PAINT 메시지가 발생하는 것을 막는데 사용함
- WM_PAINT에서 BeginPaint 함수를 사용하지 않으면 WM_PAINT 메시지가 계속 발생하여 무의미하게 CPU를 사용하는 문제가 발생
   - ValidateRect을 이용해 해결함

## bSetupPixelFormat()
- OpenGL에서 사용하기 위하여 GDI에서 제공하는 화소형식을 적절히 지정해야 함

```c++
bool bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd;
    int pixelformat;

    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.dwLayerMask = PFD_MAIN_PLANE;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cDepthBits = 16;
    pfd.cAccumBits = 0;
    pfd.cStencilBits = 0;

    if ((pixelformat = ChoosePixelFormat(hdc, &pfd)) == 0) {
        MessageBox(NULL, "ChoosePixelFormat() failed!!!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    if (SetPixelFormat(hdc, pixelformat, &pfd) == false) {
        MessageBox(NULL, "SetPixelFormat() failed!!!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    return true;
}
```
## The Window Procedure
```c++
//
//  함수: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  용도: 주 창의 메시지를 처리합니다.
//
//  WM_COMMAND  - 애플리케이션 메뉴를 처리합니다.
//  WM_PAINT    - 주 창을 그립니다.
//  WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT clientRect;
    switch (message)
    {
    case WM_CREATE:
        // Initialize for the OpenGL rendering
        hDeviceContext = GetDC(hWnd);
        if (!bSetupPixelFormat(hDeviceContext)) {
            MessageBox(hWnd, "Error in setting up pixel format for OpenGL", "Error", MB_OK | MB_ICONERROR);
            DestroyWindow(hWnd);
        }
        hRenderingContext = wglCreateContext(hDeviceContext);
        wglMakeCurrent(hDeviceContext, hRenderingContext);
        break;

    case WM_SIZE:
        GetClientRect(hWnd, &clientRect);
        Resize(clientRect.right, clientRect.bottom);
        InvalidateRect(hWnd, NULL, false);

        break;
        /*
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // 메뉴 선택을 구문 분석합니다:
            switch (wmId)
            {
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
        */
    case WM_PAINT:
    {
        DrawScene(hDeviceContext);
        ValidateRect(hWnd, NULL);

        /*
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다...
            EndPaint(hWnd, &ps);
            */
    }
    break;
    case WM_DESTROY:
        // Destroy all about OpenGL
        if (hRenderingContext)
            wglDeleteContext(hRenderingContext);
        if (hDeviceContext)
            ReleaseDC(hWnd, hDeviceContext);
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
```

## 가상 키 사용
```c++
case WM_KEYDOWN:
            switch (wParam)
            {
                case VK_LEFT:
                    // Process the LEFT ARROW key.
                    break;
                case VK_RIGHT:
                    // Process the RIGHT ARROW key.
                    break;
                case VK_UP:
                    // Process the UP ARROW key.
                    break;
                case VK_DOWN:
                    // Process the DOWN ARROW key.
                    break;
                // Process other non-character keystrokes.
                default:
                    break;
            }
```

## 속성
- 기하학적 primitve를 렌더링하는 방법을 결정하는 속성(물체들의 외형)
   - 컬러(points, lines, polygons)
   - 사이즈와 너비(points, lines)
   - 스티플 패턴(lines, polygons)
   - 폴리곤 모드(Polygon mode)

![example](https://math.hws.edu/eck/cs424/notes2013/images/06/gl-primitives.png){:.ioda}

## POLYGON
- Loop로 닫혀 있지만, 내부가 있는 물체

```c++
glColor3f(1.0f, 0.0f, 0.0f);
glBegin(GL_POLYGON);
    glVertex2f(0, 0);
    glVertex2f(0, 100);
    glVertex2f(100, 100);
    glVertex2f(100, 0);
glEnd();
```

## POINTS
```c++
glPointSize(5.0f)
glBegin(GL_POINTS);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(200, 200);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 점 4개 출력
```

## LINES
```c++
glLineWidth(5.0f)
glBegin(GL_LINES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 선 2개 출력
```

## LINE STRIP
```c++
glLineWidth(5.0f)
glBegin(GL_LINE_STRIP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 ㄷ 오른쪽으로 돌린 모양 출력
```

## LINE LOOP
```c++
glLineWidth(5.0f)
glBegin(GL_LINE_LOOP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 ㅁ 출력
```

## LINE STIPPLE
```c++
glEnable(GL_LINE_STIPPLE);
glLineWidth(5.0f)
glLineStipple(3, 0xcccc)
glBegin(GL_LINE_LOOP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd();
glDisable(GL_LINE_STIPPLE) // 펀칭되어있는 ㅁ 출력
```

## 연습문제
```c++
glColor3f(0.0f, 0.0f, 0.0f);
   glLineStipple(3, 0x1C47);
   glLineWidth(5);
      glEnable(GL_LINE_STIPPLE);
      glBegin(GL_LINES);
        glVertex2f(100, 200);
        glVertex2f(200, 200);
      glEnd();
      glDisable(GL_LINE_STIPPLE);
```

## TRIANGLES
```c++
glBegin(GL_TRIANGLES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 삼각형 출력
```

## TRIANGLES STRIP
```c++
glBegin(GL_TRIANGLE_STRIP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 삼각형 2개 출력
```
처음 세 개 정점으로 삼각형을 그린 뒤, 정점이 추가 될 떄마다 삼각형을 직전 두 개 정점과 연결하여 삼각형 추가

## TRIANGLES FAN
```c++
glBegin(GL_TRIANGLE_FAN);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 사각형 출력
```

## Attribute

## OpenGL 카메라
- -z 방향을 가리키는 세계공간의 원점에 카메라를 배치함
- 기본 관측 공간: 한 변의 길이가 2인 원점 중앙에 있는 상자
- 지역좌표(모델좌표): 피사체
- 세계좌표(월드좌표): 무엇을 기준으로 이동, 회전할까
- 쉐이딩: 피사체들이 입거나 가지고 있는 색

```c++
gluLookAt(viewer[0], viewer[1], viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
glRotatef(theta, 1.0f, 0.0f, 0.0f);
///
gluLookAt(2.0, 2.0, 2.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); // 3차원으로 만들어 줌
``
```

## OpenGL에서 초기 카메라
- 객체 프레임의 원점에 놓임
- -z축의 음수방향을 향함
- 직교관측으로 설정됨
- 기본 투영면은 z=0인 면이고, 투영방향은 z축과 나란한다

## 관측(Viewing)
- 투영 행렬에 의해 수행된다.
- 먼저, 행렬 모드를 설정 -> 단위 행렬 -> 투영 행렬
- 관측의 기본 요소
   - 객체: 영상생성 과정이나 관측자와 관계없이 공간에 존재
   - 관측자: 물체의 영상을 형성하는 것
   - 투영선
   - 투영면
- 투영 중심
   - COP가 유한한 경우: 투시 관측
   - COP가 무한한 경우: 평행 관측

## 뷰포트(Viewports)
- 디스플레이 윈도우의 직사각형 영역
- 뷰 사각형과 윈도우 사각형의 종횡비가 일치하지 않아, 왜곡현상 발생 가능

## 종횡비 유지
```c++
void Resize(int width, int height)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glViewport(0, 0, width, height);

    if (width <= height)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glOrtho(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);

    return;

}
```

## 투영
- 3차원 객체가 2차원 객체로 변환되는 과정
- 모델 좌표계, 전역 죄표계, 시점 좌표계를 순차적으로 거친 다각형 정점 좌표를 2차원 투영면에 사상시키는 과정
- 시선: 물체 곳곳을 향함
- 시선: 초점을 향함
- 관찰자 위치: 투영 중심 = 시점 좌표계 원점
- 투시 투영: glFrustum, gluPerspective(시야각 y축)
- 직교 투영: glOrtho
- 축측 세 각이 모두 같으면 등각 투영, 두 각이 같으면 이각 투영, 모두 다르면 삼각 투상

## 클리핑
- 투영은 보이는 범위를 제한하기도 한다. 3차원 공간에 그려진 물체라고 해서 모두 다 보여야 하는 것은 아니며 그 중 필요한 범위를 설정하여 일부만 표시한다. 보이는 영역을 잘라내는 것을 클리핑

## 평행 투영
- 시점이 물체로부터 무한대의 거리에 있다고 간주
   - 투영선이 평행
   - 원래 물체의 평행선은 투영 후에도 평행
   - 시점과의 거리에 무관하게 같은 길이의 물체는 같은 길이로 투영

## 직교 투영
- 투영선이 반드시 투영면과 직교

```c++
glMatrixMode(GL_PROJECTION);
glLoadIdentity( );
glOrtho(left, right, bottom, top, near, far);
// near < far, 양수 음수 모두 가능
```

```c++
if (width <= height)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glOrtho(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);
```

## 다중 관측 직교 투영
- 여러 개의 투영면을 만드는데, 각각은 객체의 주면 중 하나와 평행하다.
- 일반적으로 세 개의 관측(전면, 상면, 우측면 등)을 표시한다.
- 거리와 각이 모두 보존되고 거리와 모양의 왜곡이 없음

## 축측 투영
- 투영선은 투영면에 수직이지만, 투영면은 객체에 대한 어떠한 방향에도 존재할 수 있다.
   - **등축 투영**: 만일 투영면이 삼각형 객체의 모서리에서 만나는 세 개의 주면에 대해서 대칭으로 놓여짐
   - **이축 투영**: 투영면이 두 개의 주면이 대칭되도록 놓여짐
   - **삼축 투영**: 일반적인 경우

## 경사 투영
- 투영면에 평행한 면들에 대해서만 각이 유지됨

## 투시 투영
- 투영면에서 멀리 떨어져 있는 객체는 작게, 가까운 거리에 있는 객체는 상대적으로 크게 투영
   - 시점이 물체로부터 유한한 거리가에 있다고 간주
   - 투영선이 시점에서 출발하여 방사선 모양으로 퍼져감
   - 카메라나 사람의 눈이 물체를 포착하는 방법

```c++
glMatrixMode(GL_PROJECTION);
glLoadIdentity( );
glFrustum(left, right, bottom, top, near, far);
// near과 far은 항상 양수!!
```

```c++
if (width <= height)
        glFrustum(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glFrustum(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);
```

```c++
glMatrixMode(GL_PROJECTION);
glLoadIdentity( );
gluPerspective(fovy, aspect, near, far);
// fovy: y축 방향으로 시야각
// 종횡비 = width / height
```

```c++
gluPerspective(90, (GLdouble)width / (GLdouble)height, 1.0, 10.0);
```
## 원근감
- 동일한 크기의 물체라도 시점으로부터 멀리 있는 것은 작게 보이고 가까운 것은 크게 보임
- 일점, 이점, 삼점 투시 관측의 차이는 객체의 세가지 주 방향 가운데 얼마나 많은 방향이 투영면에 평행한 가에 있음
- 삼점 투시의 겨웅 세 개의 주 방향에 평행한 모든 직선들은 세 개의 소실점에서 만남

## 소실점
- 투시 투영 결과 평행선이 만나는 점

## 투시투영변환
- 직선->직선 / 평면->평면
- 물체 정점간의 거리에 대한 축소율이 달라짐

## 등축
- 3차원 물체를 평면 상에 표현하기 위한 방법의 일종으로 x, y, z세 좌표푹이 서로 이루는 각도가 모두 같거나 120도를 이루는 특성

## 시야각
- 카메라의 시야각 안에 들어오는 물체만 이미지로 나타남

## 뷰 볼륨
- 장면으로 잘라내는 공간
- frustum - 잘려진 피라미드

## 그림자 폴리곤
- 과정을 (x1, y1, z1)에 위치
- (-x1, -y1, -z1)만큼 평행 이동
- 원점 중심으로 투시 투영
- 다시 (x1, y1, z1)만큼 평행 이동

```c++
//shadow Polygon 변수 추가
GLfloat light_pos[3] = { -1.0f, 10.0f, -1.0f };
void Quad_NC(int a, int b, int c, int d);
```

```c++
GLfloat m[16];
    for (int i = 0; i < 16; i++) m[i] = 0.0f;
    m[0] = m[5] = m[10] = 1.0f;
    m[7] = -1.0f / light_pos[1];

    glPushMatrix();
    glTranslatef(0.0f, -1.5f, 0.0f);
    glTranslatef(light_pos[0], light_pos[1], light_pos[2]);
    glMultMatrixf(m);
    glTranslatef(-light_pos[0], -light_pos[1], -light_pos[2]);


    glColor3f(0.5f, 0.5f, 0.5f);
    glBegin(GL_QUADS);
    Quad_NC(0, 3, 2, 1);
    Quad_NC(1, 2, 6, 5);
    Quad_NC(2, 3, 7, 6);
    Quad_NC(3, 0, 4, 7);
    Quad_NC(4, 5, 6, 7);
    Quad_NC(5, 4, 0, 1);
    glEnd();
    glPopMatrix();
```

</div>
</details>

<details>
<summary>기말고사</summary>
<div markdown="1">

## 이동

$\begin{bmatrix}x\\y\\z\\1 \end{bmatrix}$

</div>
</details>