---
layout: post
category: Algo
---
> `공부 목적`으로 작성한 포스팅입니다. 오타가 많고, 틀린 내용이 있을 수 있습니다.

## 목차
* [Main Solution]
  + [Find desired node from root](#find-desired-node-from-root)
  + [Create a Directory](#create-a-directory)
  + [Remove a Subtree](#remove-a-subtree)
  + [Copy a Subtree](#copy-a-subtree)
  + [Move a Subtree](#move-a-subtree)
  + [Count directories](#count-directories)
* [Details of Main solution]
  + [Concept of Linear Time](#concept-of-linear-time)
  + [Performance of Common Routines](#performance-of-common-routines)
  + [Finding a Child](#finding-a-child)
  + [Create a Directory](#create-a-directory)
  + [Remove a Subtree](#remove-a-subtree)
  + [Copy a Subtree](#copy-a-subtree)

---
{: data-content="start!"}

## `Main solution`

## Find desired node from root
- always remember root node and start tree
- find next path componet form input string
- find component in the list (array) of children
- move to that child node
- repeat

**Performance Point: how to find child fast

**Update "counts" for ancestors**
- The change to be made can easily be calculated
- Simply follow parent pointer until root
- While applying changes to each node encountered

## Create a Directory
- Do "Find desired node from root"
- Make a new child by adding name to the list and allocating and linking a new node
- Update "Counts" for ancestors: the **changes is +1**

**Performance Point: Allocating a node

## Remove a Subtree
- Do "Find desired node from root"
- Remove the link from parent
- Update "Counts" for ancestors: the change, -"Count" value of node to be removed

**Performance Point: What to do with removed nodes?

## Copy a Subtree
- Do "Find desired node form root", 2 times
- Copy all the nodes in subtree one by one, by Traversing the subtree
- Update "Counts" for ancestors: the change, "Count" of souce node to ancestors of target

**Performance Point: what if too many directories are copied?

## Move a Subtree
- Do "Find desired node form root", 2 times
- Simply relink the node to new location
- Update "Counts" for ancestors: the change, -"Count" for source and +"Count" for target

## Count directories
- Do "Find desired node form root"
- Simply report the stored "Count"
- Things all depend on how to maintain "Count" correctly

---
## `Details of Main solution`

## Concept of Linear Time
- Linear time means: Spending time at most a few times larger than the time to read the input
- You are OK as long as you spend linear time **you have to read the input anyway**

입력으로 받은 데이터의 양의 비례하는 정도의 작업을 진행한다. 

## Performance of Common Routines
- "Find desired node from root" accesses Linear Number of Nodes 
   - Have to find a child from list of children by name
- Updating "Count" for Ancestors also accesses Linear Number of Nodes 
   - Spends constant time in a node

## Finding a Child
- Limits set in the Problem Statement
   - There are at most 30 children for a node
   - THere are at most 6 characters in a path name component
- Simple linear search will work because 30 is quite small
   - We could use things like TRIE's, but the benefit will not be big
- You can pack the name in one 32-bit variable
   - 5 bits are enough for one character
   - Reduces 6 comparisons to 1 comparison - quite a big benefit

## Create a Directory
- Only performance concern is allocating a node
- Use system allocation
   - could be slow
- limit set in the problem statement
   - At most 50,000 directories created
- Just preallocate 50,000 Nodes and use them one by one
   - You will not need more than that and there is no need for reusing memory

## Remove a Subtree
- Only performance concern is what to do with removed nodes
- THe Answer: you don't care
   - you don't even have to find the nodes
   - you just delink the top of the subtree an forget the rest
   - Trying to identify the removed nodes will take time
   - Reusing the memory is no concern here (at mos 50,000 directories created)

## Copy a Subtree
- Do a Tree Traversal to copy nodes recursively
- One Performance Concern is what if too many directories are copied
   - Limits set by the Problem Statement
      - At most 10% of all operations are copied
         - doesn't really matter
      - At most 50,000 directories created
         - This ensures "large" copied will be very rare

![dire](./image/dire.png)

```java
Trav(Node *p){
    do some work for p // for this problem, copy node for each node q in p
        Trav(q)
}

//That is, recursive call each child separately 
```
