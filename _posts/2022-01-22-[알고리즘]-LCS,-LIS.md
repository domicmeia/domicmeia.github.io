---
layout: post
category: Algo
---
> `공부 목적`으로 작성한 포스팅입니다. 오타가 많고, 틀린 내용이 있을 수 있습니다.

## 목차
* [LCS(Longest Common Subsequence)]
  + [LCS(Longest Common Subsequence)란](#lcs(longest-common-subsequence)란)
  + [LCS의 길이 찾기 - `DP`](#lcs의-길이-찾기---`dp`)
    - [Top-Down](#top-down)
    - [Bottom-Up](#bottom-up)
* [LIS(Longest Increasing Subsequence)]
  + [LIS(Longest Increasing Subsequence)란](#lis(longest-increasing-subsequence)란)

---
{: data-content="start!"}

## LCS(Longest Common Subsequence)란
보통의 LCS는 최장 공통 부분수열(Longest Common Subsequence)을 말하지만, 최정 공통 문자열(Longest Common Substing)을 말하기도 한다. 이 둘은 비슷하지만, 비교하는 두 문자가 다를 때 차이를 보인다. 먼저, Subsequence은 연속된 값이 아니다. 현재의 문자를 비교하는 과정 이전의 최대 공통 부분수열은 계속해서 유지된다. 반면에, Substing은 연속된 부분 문자열이다. 예를 들어 **IAMHUNGRY**에서 **MHUN**은 **Substring**이 되고, **MUGY**는 **Subsequence**가 된다. 이 포스팅에서 언급하는 LCS는 최장 공통 부분수열이다.  

LCS란 주어진 여러 개의 수열 모두의 부분수열이 되는 수열들 중에 가장 긴 것을 찾는 문제이다. 예를 들어 **ABCDGH**과 **AEDFHR**을 input했을 때, LCS는 **ADH**이며 그 길이는 3이다. 또한 **AGGTAB**과 **GXTXAYB**를 input했을 때, LCS는 **GTAB**이며 그 길이는 4이다. 그렇다면 어떻게 코드로 LCS의 길이를 찾을 수 있을까?

## LCS의 길이 찾기 - `DP`
가장 일반적인 방법은 각 원소들을 하나씩 직접 비교해주면서 dp값을 갱신하는 것이다. 주어진 문자열의 길이를 각각 m, n이라고 하고 각 문자열을 배열로 표현하면 X[0..m-1] and Y[0..n-1]이다. 그럼 **L(X[0..m-1], Y[0..n-1])**을 X와 Y의 LCS의 길이를 반환하는 함수라고 가정하자.  

부분수열은 연속된 값이 아니기에 현재의 문자를 비교하는 과정 이전의 최대 공통 부분수열은 유지되어야 한다. 따라서 만약 두 문자열의 마지막 문자가 같다면 `L(X[0..m-1], Y[0..n-1]) = 1 + L(X[0..m-2], Y[0..n-2])` 일 것이다. 즉, 같은 문자를 찾으면 LCS의 길이를 1 증가시키고 각 문자열을 하나씩 줄인 뒤 다시 LCS를 찾는 재귀형식으로 접근할 수 있다.  

만약 두 문자열의 마지막 문자가 같지 않다면 `L(X[0..m-1], Y[0..n-1]) = MAX ( L(X[0..m-2], Y[0..n-1]), L(X[0..m-1], Y[0..n-2]) )`이다. 즉, 한쪽의 문자열의 길이는 **-1**이 되고, 한쪽은 그대로 남는다. 그리고 그 남은 문자열들 중에서 LCS를 다시 찾아 가장 긴 문자열을 찾는다. 이렇게 이 문제는 최적 부분 구조를 만족한다. 그럼 이를 풀어보자.
```c++
#include <bits/stdc++.h>
using namespace std;
/* Returns length of LCS for X[0..m-1], Y[0..n-1] */
int lcs( char *X, char *Y, int m, int n )
{
	if (m == 0 || n == 0)
		return 0;
	if (X[m-1] == Y[n-1])
		return 1 + lcs(X, Y, m-1, n-1);
	else
		return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));
}
/* Driver code */
int main()
{
	char X[] = "AGGTAB";
	char Y[] = "GXTXAYB";
	int m = strlen(X);
	int n = strlen(Y);
	cout<<"Length of LCS is "<< lcs( X, Y, m, n ) ;
	return 0;
}
// This code is contributed by rathbhupendra
```
이 코드의 실행 부분 중 문자열 AXYT과 AYZX의 부분 재귀 트리는 다음과 같다.
![axy](./image/axy.png)
Overlaping SubProblem이 발생함을 알 수 있다. Top-Down과 Bottom-up으로 문제를 해결하자. 
## Top-Down

```c++
#include <bits/stdc++.h>
using namespace std;
const int maximum = 1000;
int lcs(string X, string Y, int m, int n, int dp[][maximum])
{
	// base case
	if (m == 0 || n == 0)
		return 0;
	// if the same state has already been
	// computed
	if (dp[m - 1][n - 1] != -1)
		return dp[m - 1][n - 1];
	// if equal, then we store the value of the
	// function call
	if (X[m - 1] == Y[n - 1]) {
		// store it in arr to avoid further repetitive
		// work in future function calls
		dp[m - 1][n - 1] = 1 + lcs(X, Y, m - 1, n - 1, dp);
		return dp[m - 1][n - 1];
	}
	else {
		// store it in arr to avoid further repetitive
		// work in future function calls
		dp[m - 1][n - 1] = max(lcs(X, Y, m, n - 1, dp),
							lcs(X, Y, m - 1, n, dp));
		return dp[m - 1][n - 1];
	}
}
// Driver Code
int main()
{
	string X = "AGGTAB";
	string Y = "GXTXAYB";
	int m = X.length();
	int n = Y.length();
	int dp[m][maximum];
	// assign -1 to all positions
	memset(dp, -1, sizeof(dp));
	cout << "Length of LCS: " << lcs(X, Y, m, n, dp);
	return 0;
}
```
## Bottom-Up

```c++
#include<bits/stdc++.h>
int max(int a, int b);
/* Returns length of LCS for X[0..m-1], Y[0..n-1] */
int lcs( char *X, char *Y, int m, int n )
{
    int L[m+1][n+1];
    int i, j;
/* Following steps build L[m+1][n+1] in bottom up fashion. Note
	that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1] */
    for (i=0; i<=m; i++){
        for (j=0; j<=n; j++){
            if (i == 0 || j == 0)
            L[i][j] = 0;
            else if (X[i-1] == Y[j-1])
            L[i][j] = L[i-1][j-1] + 1;
            else
            L[i][j] = max(L[i-1][j], L[i][j-1]);
            }
    }	
/* L[m][n] contains length of LCS for X[0..n-1] and Y[0..m-1] */
return L[m][n];
}
/* Utility function to get max of 2 integers */
int max(int a, int b){
	return (a > b)? a : b;
}
/* Driver program to test above function */
int main(){
    char X[] = "AGGTAB";
    char Y[] = "GXTXAYB";
    int m = strlen(X);
    int n = strlen(Y);
    printf("Length of LCS is %d", lcs( X, Y, m, n ) );
    return 0;
}
```

## LIS(Longest Increasing Subsequence)란
어떤 수열이 왼쪽에서 오른쪽으로 나열되어 있으면, 그 배열 순서를 유지하면서 크기가 점진적으로 커지는 긴 부분수열을 추출하는 문제이다. 이 때, 부분 수열의 각 수는 서로 연속할 필요는 없다. 예를 들어, [3, 2, 6, 4, 5, 1]에서 최장 증가 수열은 [2, 4, 5]이다. 이를 어떻게 구할 수 있을까?

## Brute-Force 접근 방법[^1]
수열의 모든 부분 집합을 구하여 그 부분 집합이 증가 수열인지 판별한다. 그리고 증가 수열 중 가장 길이가 긴 값을 찾는다. 

---
{: data-content="footnotes"}

[^1]: Brute-Force란 직역하면 무식하게 풀기를 의미한다. 문제가 주여졌을 때 일어날 수 있는 모든 경우의 수를 계산하여 원하느 출력값을 얻는다. 이는 컴퓨팅 자원을 극심하게 소모하기 때문에 입력값이 작을 것으로 기대될때만 사용하는 것이 좋다. 