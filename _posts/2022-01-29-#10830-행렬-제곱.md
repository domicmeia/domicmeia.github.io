---
layout: post
category: BOJ
---

## Problem
크기가 N*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.

## Input
첫째 줄에 행렬의 크기 N과 B가 주어진다. (2 ≤ N ≤  5, 1 ≤ B ≤ 100,000,000,000)  
둘째 줄부터 N개의 줄에 행렬의 각 원소가 주어진다. 행렬의 각 원소는 1,000보다 작거나 같은 자연수 또는 0이다.

## Output
첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다.

## Thought
B는 최대 100,000,000,000의 값을 갖기 때문에 int를 초과하므로 long long으로 선언한다. 입력값이 너무 크기 때문에, 최적화를 위해 DP 혹은 분할 정복, 비트마스크 등으로 풀 수 있을 것 같다. 본 풀이는 분할정복(빠른 거듭제곱 알고리즘)으로 풀었고, 지수를 절반씩 잘라가면서 풀었다. 문제에서 __수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.__ 라고 했으니 A의 원소가 1000으로 하나고 B가 1인 경우를 예외처리하기 위해서 마지막 출력에서 1000을 나눠준다. (단위 행렬을 만들어줘도 된다.)

### 빠른 거듭제곱 알고리즘
![speed](./image/speed.png)

## Code
```c++
#include <bits/stdc++.h>
using namespace std; 
int N; 
long long B; 
vector<int> matrixMultiply(vector<int> &A, vector<int> &B){
    vector<int> C(N * N); 
    for(int i = 0; i < N; i++){
        for(int j = 0; j < N; j++){
            for(int k = 0; k < N; k++){
               	C[i*N+j] = (C[i*N+j] + A[i*N+k] * B[k*N+j]) % 1000;
            }
        }
    }	
    return C;
}
vector<int> divideNconquer(vector<int> & A, long long p){
    if(p == 1) return A; //지수가 1일 때
    vector<int> C = divideNconquer(A, p / 2); 
    C = matrixMultiply(C , C); 
    if(p % 2) C = matrixMultiply(C, A); // 지수가 홀수 일 때
    return C; 
}   
int main(){
    ios_base::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL);
    cin >> N >> B;
    vector<int> A(N * N), ans; 
    for(int i = 0; i < N * N; i++) cin >> A[i];
    ans = divideNconquer(A, B);
    for(int i = 0; i < N; i++){
        for(int j = 0; j < N; j++){
            cout << ans[i * N + j] % 1000 << ' ';
        }
        cout << '\n';
    }   
    return 0; 
} 
```