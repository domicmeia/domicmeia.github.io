---
layout: post
category: Note
---
> `공부 목적`으로 작성한 포스팅입니다. 오타가 많고, 틀린 내용이 있을 수 있습니다.

## Vector 클래스
벡터에 연산자 오버로딩을 사용하는 이유는
1. 벡터는 하나의 값으로 나타낼 수 없으므로, 벡터를 나타내는 클래스를 정의하는 것이 비슷하다.
2. 벡터 연산은 덧셈이나 뺄셈과 같은 일반적인 산술 연산과 비슷하다.

벡터는 크기(길이)와 방향(각도)로 나타낼 수 있고, x성분과 y성분으로도 나타낼 수 있다. 어떤 경우에는 직각 좌표 형식이 편하고, 다른 경우에는 극 좌표 형식이 편할 것이다. Vector 클래스에서는 어떤 벡터의 한 가지 표현 형식을 바꾸면, 객체가 자동으로 다른 표현 형식도 갱신하도록 설계되었다. C++에 내장된 수학 함수들은 라디안 단위의 각도를 사용하는데, Vector 클래스 구현은 극 좌표를 직각 좌료로 변환하거나 라디안 단위를 도 단위로 변환하는 일들을 사용자가 볼 수 없도록 숨긴다.

### at

```c++
reference at(size_type position);
const_reference at(size_type position) const;
```
`position`이 벡터 크기보다 크면 `at`에서 예외를 throw. `[]`에 의한 접근은 첨자의 범위를 체크하지 않기 때문에 범위를 벗어난 접근을 시도할 경우 예외를 발생하지 않고 에러를 발생한다. 반면에, `at`을 이용한 접근은 첨자의 범위를 체크하여 벗어난 접근을 시도할 경우 `std::out_of_range` 예외를 발생한다. 
**범위 내의 접근을 보장할 경우 별도의 범위 체크가 필요 없으므로 []에 접근하고, 그렇지 않을 경우 at에 의한 접근으로 예외 처리 해준다.**

```c++
for ( int n = 0; n < (int)vInt.size(); ++n )
{
  int a = vInt[ n ];
  :
}
```
```c++
void no( int n )
{
	try
	{
		int a = vInt.at( n );
	}
	catch (std::out_of_range& e)
	{
		AfxMessageBox( _T("Catch the std::out_of_range") );
	}
}
```





[cplus]: https://www.cplusplus.com/reference/vector/vector/assign/