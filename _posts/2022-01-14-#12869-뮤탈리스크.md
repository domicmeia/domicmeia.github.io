---
layout: post
category: BOJ
---
> 2022년 1월부터 진행한 알고리즘 스터디의 기록장입니다. 모든 문제는 [자가비의 추천문제#1(zagabi)][zagabi]에서 셀렉 됐습니다!

## Problem
수빈이는 강호와 함께 스타크래프트 게임을 하고 있다. 수빈이는 뮤탈리스크 1개가 남아있고, 강호는 SCV N개가 남아있다.
각각의 SCV는 남아있는 체력이 주어져있으며, 뮤탈리스크를 공격할 수는 없다. 즉, 이 게임은 수빈이가 이겼다는 것이다.
뮤탈리스크가 공격을 할 때, 한 번에 세 개의 SCV를 공격할 수 있다.

- 첫 번째로 공격받는 SCV는 체력 9를 잃는다.
- 두 번째로 공격받는 SCV는 체력 3을 잃는다.
- 세 번째로 공격받는 SCV는 체력 1을 잃는다.

SCV의 체력이 0 또는 그 이하가 되어버리면, SCV는 그 즉시 파괴된다. 한 번의 공격에서 같은 SCV를 여러 번 공격할 수는 없다.
남아있는 SCV의 체력이 주어졌을 때, 모든 SCV를 파괴하기 위해 공격해야 하는 횟수의 최솟값을 구하는 프로그램을 작성하시오.

## Input
첫째 줄에 SCV의 수 N (1 ≤ N ≤ 3)이 주어진다. 둘째 줄에는 SCV N개의 체력이 주어진다. 체력은 60보다 작거나 같은 자연수이다.

## Output
첫째 줄에 모든 SCV를 파괴하기 위한 공격 횟수의 최솟값을 출력한다.

## Thought
재귀호출을 사용해야 할 것 같은데, DFS로 풀다가는 스택 오버플로우가 발생할 것 같았다. 고민하다 BFS로 풀었다. BFS는 항상 최적을 보장하니까..
큐를 이용해서 공격 횟수의 최소값을 구하면 될 것 같다. 메모리 초과를 방지해서 visited를 이용해 확인하지 않은 부분만 큐에 담아준다. 
1. 공격 조합은 3 x 2 x 1 -> {9, 3, 1},{9, 1, 3},{3, 1, 9},{3, 9, 1},{1, 3, 9},{1, 9, 3}
2. 남아있는 SCV 체력을 vector에 저장, 인덱스가 음수일 수는 없으니까 값이 0 미만일 경우 0으로 초기화
3. BFS or DP는 사용할 수 있다. 레벨 별로 확인하기
4. [0][0][0]에 도달할 경우, 그 정점 -1을 출력한다. 

## Code
```c++
#include <bits/stdc++.h>
using namespace std;
#define INF 987654321

int dp[61][61][61], a[3], n, visited[61][61][61];
int _a[6][3] = {
    {9, 3, 1}, {9, 1, 3}, {3, 1, 9}, {3, 9, 1}, {1, 3, 9}, {1, 9, 3}};

struct A
{
    int a, b, c;
};

queue<A> q;
int solve(int a, int b, int c)
{
    visited[a][b][c] = 1;
    q.push({a, b, c});
    while (q.size())
    {
        int a = q.front().a;
        int b = q.front().b;
        int c = q.front().c;
        q.pop();
        if (visited[0][0][0])
            break;
        for (int i = 0; i < 6; i++)
        {
            int nexta = max(0, a - _a[i][0]);
            int nextb = max(0, b - _a[i][1]);
            int nextc = max(0, c - _a[i][2]);
            if (visited[nexta][nextb][nextc])
                continue;
            visited[nexta][nextb][nextc] = visited[a][b][c] + 1;
            q.push({nexta, nextb, nextc});
        }
    }
    return visited[0][0][0] - 1;
}

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> a[i];
    cout << solve(a[0], a[1], a[2]) << "\n";
    return 0;
}
```

[zagabi]: https://www.acmicpc.net/workbook/view/4344