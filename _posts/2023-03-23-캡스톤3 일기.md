---
layout: post
category: Note
use_math: true
---

## django-allauth의 /account와 프로젝트 내 /account 충돌

초기 세팅에서 우리는 이미 account app을 생성했다. 하지만, Django-allauth도 내부의 account app이 있어서 usermodel이 충돌했다. 둘 중 하나를 바꿔야 했다.
```python
# setting.py
INSTALLED_APPS = [
    ...
    'account',
    ...

    # For allauth:
    'django.contrib.sites',
    'allauth',
    'allauth.account',
    ...
```

이러면 *Application labels aren’t unique, duplicates: account* 오류가 뜬다. </br>
same label을 사용하고 있어서, accout에 unique한 label을 넣어줘야 한다.
```python
# account/apps.py
from django.apps import AppConfig


# class AccountConfig(AppConfig):
#     default_auto_field = 'django.db.models.BigAutoField'
#     name = 'account'

class AccountConfig(AppConfig):
    name = 'account'
    label = 'local_user'  # Change this
```

다음으로 **setting.py**도 변경해준다.
```python
# setting.py
INSTALLED_APPS = [
    ...
    'account.apps.AccountConfig', #change this from 'account'
    ...
]
```

하단에 usermodel도 변경해준다.
```python
# setting.py
AUTH_USER_MODEL = 'local_user.User'
```

이전의 *account*에서 migrate한 내용을 모두 삭제하고, 다시 migration 해주면 해결.

## 인증 방식 변경

## Session, Cookie method

- Existing authentication method used a method of authenticating a user using a session in the server.
- When a client requests authentication, user information is verified in the DB and a unique session ID is stored in the session storage.
- Afterwards, a cookie is issued to the header, and revalidation is performed in Session Storage through the cookie.
- In other words, Session-based authentication can be easily expressed as stateful because it manages the state in the server.

## Disadvantages of Session and Cookie method

- Server expansion is difficult.
  - As business traffic increases, consider scaling up or scaling out the server.
  - Usually, scale out is considered rather than increasing the server's specifications, but if there are several servers, there are also several session stores. Accordingly, the user authentication process cannot be properly implemented unless a memory-based session storage such as Redis is separately built and sessions are managed. It is possible to save the session in the DB, but it takes a lot of time to search the DB each time during the authentication process.
  - Therefore, as it scales out, the session storage must be managed separately.

- load the server.
  - Session storage eventually puts a load on the server according to the increase in traffic.

- Session can be hijacked.
  - During the communication process, the session ID of the cookie is stolen and the server can provide user information to the hacker.
  - It is prevented by setting the expiration time of the session, but it is difficult to completely prevent it.

## What is JWT

JWT, as you can check on the official website, it is divided into three parts, HEADER.PAYLOAD.SIGNATURE.

- **Header**: Consists of encryption algorithm and token type. It is base64 encoded.
- **PayLoad**: This part is the data that we directly set, and each key-value is called a claim. Usually, subject, userId, expiredTIme, issuedTime, etc. are set. PayLoad should never include personal information such as passwords. Because anyone can easily interpret it. It is base64 encoded.
- **Verify signature**: The last part is the part where validation is performed by verifying the signature. It is generated using an algorithm based on the key set in the server and encoded in base64. validation is possible. Therefore, the key set on the server should not be disclosed.

JWT is just plain text except that it contains some information.

When logging in, simply create text on the client and

When authentication is required, the server receives text and proceeds with authentication. This eliminates the need for the server to manage.

It is said to be stateless because it does not maintain state.

## How to make up for token weaknesses

- In practice, when issuing a token, two types of tokens are issued. An access token with a short expiration time and a refresh token with a long expiration time are issued.
- Since access tokens are usually stored in client storage, they are highly likely to be stolen. Therefore, set the expiration time short.
- Refresh Token sets a long expiration time and stores it in a storage such as a DB.
- When the Access Token expires, the Refresh Token is used to reissue the Access Token.

## What to do if the Refresh Token is stolen?
The refresh token was created considering the stealing of the access token, but if the refresh token is stolen, it can be said to be the worst case scenario.

It is the worst if a new Access Token is issued by stealing the Refresh Token.

There is no way around these scenarios other than to prevent them as much as possible.

## to prevent
- HttpOnly setting: Refresh Token is usually delivered through cookies, but attacks such as XSS can be blocked through httpOnly setting.
- RTR method: Refresh Token Rotation method, when a new Access Token is received as a Refresh Token, a new Refresh Token is also received. Through this, the previously issued token can be prevented from being used.
 - If this method is used, the Refresh Token is issued and then used only once and discarded. Therefore, if the same Refresh Token is used more than once, the Refresh Token can be regarded as stolen and action taken.