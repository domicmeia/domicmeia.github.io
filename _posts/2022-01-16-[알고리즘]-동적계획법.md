---
layout: post
category: Algo
---
> 공부 목적으로 작성한 포스팅입니다. -

DP 문제집을 풀기 전에 DP를 한번 더 복습하는 마음으로 글을 작성한다. DP 방법으로 문제를 거의 푼 적이 없어서, 한번 날 잡고 풀어보려 한다.
일단 동적 계획법(Dynamic Programming)은 큰 문제를 작은 문제로 나눠서 푸는 알고리즘이다. 피보나치 수열을 예로 들자.

## 재귀 - 피보나치
```c
int fibo(int n)
  {
    if (n<=2)
      return 1;
    else
      return fibo(n-1) + fibo(n-2);
   }
```
이 함수는 피보나치 수열의 n번째 수를 구하는 함수이다. fibo(6)은 아래와 같이 진행된다.
![fibo1](./image/fibo1.png)
이미 진행된 연산인 fibo(4)와 fibo(3)이 여러번 진행된 것을 볼 수 있다. 이러한 반복 연산의 결점을 보완한 알고리즘이 바로 DP이다.

## DP 사용 조건
DP가 적용되기 위해서는 2가지 조건을 만족해야 한다. Optimal Substructure와 Overlaping SubProblem이다. 계속 예를 들어보자. 
피보니치 수열의 식은 `F(n)=F(n-1)+F(n-2) (n>2)`이다. 이 식은 다음의 두 가지를 보인다.

1. F(n-1)과 F(n-2)을 더하면 F(n)이 나온다. 
2. 귀납법의 증명을 통해 n=k일 때 성립하면 n=k+1도 성립한다. 즉, F(k+1)=F(k)+F(k-1)또한 성립한다.

첫번째를 `Optimal Substructure(최적 부분 구조)`라 한다. 큰 문제의 정답을 작은 문제를 통해 풀이하는 것을 의미한다. 그래서 특정 문제의
정답은 문제의 크기에 상관없이 항상 동일하다. 예를 들어 A 지점에서 B지점까지 가는 중간에 X가 있다고 가정하자. A에서 X로 가는 경우의
수가 얼마나 많든, X에서 B로 가는 경우의 수가 얼마나 많든 상관없이 A-X/X-B가 가장 짧은 경로라면 전체 최적 경로도 A-X-B이다. 이와 같이
<u>부분 문제에서 구한 최적 결과가 전체 문제에서 동일하게 적용되어 결과가 변하지 않을 때<u> DP를 사용할 수 있다.

두번째를 `Overlaping SubProblem(겹치는 부분 문제)`라 한다. 예를 들어 F(4)=F(3)+F(2)과 F(3)=F(2)+F(1) 식에서 F(3)과 F(2)항이 겹친다.
DP는 기본적으로 문제를 나누고 그 문제의 결과값을 재활용하여 전체 답을 구한다. 그래서 <u>동일한 작은 문제들이 반복하여 나타나는 경우에만
사용이 가능<u>하다. 그러므로 우리는 1회 계산했을 때의 값을 저장해 다음 피보나치 식에서 이를 재사용한다. 

