---
layout: post
category: Algo
---
> `공부 목적`으로 작성한 포스팅입니다. 오타가 많고, 틀린 내용이 있을 수 있습니다.

## 목차
* [그리디 알고리즘](#그리디-알고리즘)
* [문제 해결]
  + [예제 - 거스름돈](#예제---거스름돈)
  + [실전문제 - 큰 수의 법칙](#실전문제---큰-수의-법칙)
  + [실전문제 - 숫자 카드 게임](#실전문제---숫자-카드-게임)
  + [실전문제 - 1이 될 때까지](#실전문제---1이-될-때까지)

---
{: data-content="start!"}

## 그리디 알고리즘
- 문제가 있을 때, 단순 무식하게 탐욕적으로 문제를 푸는 알고리즘
- 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있음
- 코테 문제에서 문제 유형 파악하기 어렵다면 그리디 알고리즘 의심하기


## 예제 - 거스름돈

### Thought

가장 큰 화폐 단위부터 돈을 거슬러 주는 것  
가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문에 가능

### Code 1) 책에 나와있는 파이썬 코드

```python
n = 1260
count = 0

# 큰 단위의 화폐부터 차례대로 확인
coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin # 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
    n %= coin

print(count)
```

화폐의 종류가 K개라고 할 때, 시간 복잡도는 O(K) -> 동전의 총 종류에만 영향 받음

### Code 2) 나의 C++ 코드

```c++
#include <iostream>
using namespace std;

int main()
{
    int money[] = {500, 100, 50, 10};
    int n = 1260, cnt = 0;
    for (int i = 0; i < 4; i++)
    {
        cnt += n / money[i];
        n %= money[i];
    }

    cout << cnt;
    return 0;
}
```

## 실전문제 - 큰 수의 법칙

### Thought

책의 입력 예시를 보면  
5 8 3  
2 4 5 4 6  
-> 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 = 46  
  
5 7 2
3 4 3 4 3
-> 4 + 4 + 4 + 4 + 4 + 4 + 4 = 28
  
최대 숫자와 두 번째로 큰 숫자가 몇번 더해지는 것만 고려하면 된다. 첫 번째 예시의 경우  
6(최대 숫자) x 3(k) x 2(이 쌍이 몇번 반복될 수 있는지) + 5(두 번째 큰 숫자) x 1 x 2(쌍의 나머지)  

이를 수식화하면  
**K x (가장 큰 요소) x (m/k의 몫) + (두 번째로 큰 요소) x 1 x (m/k의 나머지)**

### Code

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    vector<int> v;
    int n, m, k, result = 0;
    scanf("%d%d%d", &n, &m, &k);

    for (int i = 0; i < n; i++)
    {
        int x;
        scanf("%d", &x);
        v.push_back(x);
    }

    sort(v.begin(), v.end());
    int first = v[n - 1];
    int second = v[n - 2];

    result = first * k * (m / k) + second * (m % k);
    printf("%d", result);
    return 0;
}
```
## 실전문제 - 숫자 카드 게임

### Thought

2차원 배열 입력 받고 정렬 -> 비교해서 가장 큰 수 출력하기
입력으로 들어오는 수가 10,000 이하니까 단순하게 생각해도 됨

### Code

```c++
#include <stdio.h>

int main()
{
    int n, m;
    int arr[100][100] = { // 1 <= N, M <= 100
        0,
    };
    int result = 0;
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i++)
    {
        int min = 10001;
        for (int j = 0; j < m; j++)
        {
            scanf("%d", &arr[i][j]);
            if (arr[i][j] < min)
            {
                min = arr[i][j];
            }
        }
        if (result < min)
        {
            result = min;
        }
    }
    printf("%d", result);
    return 0;
}
```

## 실전문제 - 1이 될 때까지

### Thought

1. n이 k의 배수가 될 때까지 1씩 빼기
2. n을 k로 나누기

### Code 1

```c++
#include <stdio.h>

int main()
{
    int n, k;
    int result = 0;
    scanf("%d%d", &n, &k);

    while (1)
    {
        if (n % k == 0)
        {
            n /= k;
        }
        else
        {
            n -= 1;
        }
        result++;
        if (n == 1)
            break;
    }

    printf("%d", result);
    return 0;
}
```

### Code 2
n이 100억 이상의 큰 수가 되는 경우를 가정했을 때,
```c++
#include <stdio.h>

int main()
{
    int n, k;
    int result = 0;
    scanf("%d%d", &n, &k);

    while (1)
    {
        int p = n / k; // n이 될 수 있는 가장 큰 k의 배수
        if (p == 0)
            break;
        result += n - p * k;
        n = p;
        result++;
    }

    result += n - 1; // 남은 횟수를 다 더함
    printf("%d", result);
    return 0;
}

```