---
layout: post
category: Algo
---
> `공부 목적`으로 작성한 포스팅입니다. 오타가 많고, 틀린 내용이 있을 수 있습니다.

## 목차
* [문제 해결]
  + [예제 - 상하좌우](#예제---상하좌우)
  + [실전문제 - 큰 수의 법칙](#실전문제---큰-수의-법칙)
  + [실전문제 - 숫자 카드 게임](#실전문제---숫자-카드-게임)
  + [실전문제 - 1이 될 때까지](#실전문제---1이-될-때까지)

---
{: data-content="start!"}


## 예제 - 상하좌우

### Thought

- 이동 횟수가 N번인 경우 시간 복잡도는 O(N)이다.
- 좌표값 dx, dy를 1차원 배열로 선언해서 방향을 설정.
- L/R/U/D 각각 나누기 -> String 배열로 선언.
- 현재의 좌표값과 나중의 좌표값을 따로 선언.
- 이중 for문 작성 -> 이동 방향 저장하면서 안쪽 for문에 방향 후처리.
- 공간을 벗어나는 경우를 생각해야 함 -> **이거 먼저 거르고 나서 이동 시키기.**

### Code 1) 책에 나와있는 파이썬 코드

```python
# N을 입력받기
n = int(input())
x, y = 1, 1
plans = input().split()

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

# 이동 계획을 하나씩 확인
for plan in plans:
    # 이동 후 좌표 구하기
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
    # 이동 수행
    x, y = nx, ny

print(x, y)
```

### Code 2) 나의 C++ 코드

```c++
#include <iostream>
#include <string>
using namespace std;

char dXY[4] = {'L', 'R', 'U', 'D'};
int x, y = 1;
int n;
int dx[4] = {0, 0, -1, 1};
int dy[4] = {-1, 1, 0, 0};

int main()
{
    cin >> n;
    cin.ignore();
    string plans;
    getline(cin, plans);
    for (int i = 0; i < plans.size(); i++)
    {
        int nx, ny = 0;
        for (int j = 0; j < 4; j++)
        {
            if (plans[i] == dXY[j])
            {
                nx = x + dx[j];
                ny = y + dy[j];
            }
        }
        if (nx < 1 || ny < 1 || nx > n || ny > n)
            continue;
        x = nx;
        y = ny;
    }
    cout << x << " " << y;
    return 0;
}
```