---
layout: post
category: Note
---
> `OpenGL을 이용한 컴퓨터그래픽스` 정리

## 컴퓨터 그래픽스 시스템
- 입력 -> Processor(CPU) -> Graphics Processor(GPU) -> Frame Buffer -> 모니터

## 필셀과 프레임 버퍼
- 래스터 방식: 그래픽스 시스엠 안에서 픽셀의 배열, 즉 래스터로 생성됨
- 각 픽셀은 영상의 한 위치나 작은 영역에 대응
- 픽셀은 Frame Buffer라고 부르는 메모리의 한 부분에 집단으로 저장

## 해상도
- 프레임 버퍼의 픽셀 수가 우리들이 볼 수 있는 영상의 상세함을 결정
- 각 픽셀의 비트 수로 정의되는 프레임 버퍼의 깊이. 즉, 정밀도가 주어진 시스템이 얼마나 많은 색을 표현할 수 있는지 결정함

## 래스터화 혹은 주사변화
- 응용 프로그램에 의하여 픽셀에 관한 정보를 처리하여 프레임 버퍼에 저장시키는 것

## OpenGL의 특징
- 그래픽스 하드웨어에 대한 소프트웨어 인터페이스
- 플랫폼에 독립적
- 다양한 그래픽스 기능을 지원하여 응용 소프트웨어 개발 용이
- OpenGL 가속 하드웨어는 셰이딩 언어를 하드웨어적으로 가속하는 기능 제공

## 그래픽스 파이프라인
- 3차원의 도형 혹은 이미지를 2차원 래스터 이미지로 표현하기 위한 단계적 방법

## 윈도우 GDI
- 그래픽의 출력 담당
- 프린터에 프린트하는 기능도 담당

## 유효화
- 윈도우의 클리아언트 영역을 훼손하면, 윈도우는 WM_PAINT 메시지를 응용 프로그램으로 보냄
- 프로그램은 윈도우에게 그 메시지를 받아서 처리했다는 것을 알려야 함
- 윈도우에게 알리는 과정을 사각형을 유효화 한다고 함

## WM_PAINT

### BeginPaint() ... EndPaint()
- 장점: 자동으로 유효화 수행
- 단점: 무효사각형을 나타내는 rcPaint 속성을 가지고 있으며, 윈도우의 클리핑 영역 외부에는 어떤 것도 그릴 수 없음
   - 그리고 싶다면 rcPaint를 다시 정의해야 함

### GetDC() ... ReleaseDC()
- 장점: 클리핑 사각형을 전체 클라이언트 영역이 됨. 따라서 클라이언트 영역을 그리기 위해 매번 무효 사각형을 정의할 필요가 없음
- 단점: 무효 사각형을 유효화하기 위해 직접 ValidateRect()를 호출
     - 윈도우는 유효화가 이루어지지 않으면 계속 WM_PAINT 메시지를 보냄

## 무효사각형(Invalid Rectangle)
- 다시 그릴 필요가 없는 유일한 영역
- InvalidateRect()함수는 클라이언트 영역의 임의의 부분만 그림

```c++
case WM_SIZE:
        GetClientRect(hWnd, &clientRect);
        Resize(clientRect.right, clientRect.bottom);
        InvalidateRect(hWnd, NULL, false);
        //(무효화할 윈도우 핸들/ 무효화할 사각형 영역 포인터/BeginPaint()를 위해 플래그 지움)

        break;
```

## ValidateRect 역할
- InvalidateRect의 반대
- 무효화된 영역을 유효화시켜 WM_PAINT 메시지가 발생하는 것을 막는데 사용함
- WM_PAINT에서 BeginPaint 함수를 사용하지 않으면 WM_PAINT 메시지가 계속 발생하여 무의미하게 CPU를 사용하는 문제가 발생
   - ValidateRect을 이용해 해결함

## bSetupPixelFormat()
- OpenGL에서 사용하기 위하여 GDI에서 제공하는 화소형식을 적절히 지정해야 함

```c++
bool bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd;
    int pixelformat;

    pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    pfd.dwLayerMask = PFD_MAIN_PLANE;
    pfd.iPixelType = PFD_TYPE_RGBA;
    pfd.cColorBits = 24;
    pfd.cDepthBits = 16;
    pfd.cAccumBits = 0;
    pfd.cStencilBits = 0;

    if ((pixelformat = ChoosePixelFormat(hdc, &pfd)) == 0) {
        MessageBox(NULL, "ChoosePixelFormat() failed!!!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    if (SetPixelFormat(hdc, pixelformat, &pfd) == false) {
        MessageBox(NULL, "SetPixelFormat() failed!!!", "Error", MB_OK | MB_ICONERROR);
        return false;
    }

    return true;
}
```
## The Window Procedure
```c++
//
//  함수: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  용도: 주 창의 메시지를 처리합니다.
//
//  WM_COMMAND  - 애플리케이션 메뉴를 처리합니다.
//  WM_PAINT    - 주 창을 그립니다.
//  WM_DESTROY  - 종료 메시지를 게시하고 반환합니다.
//
//
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT clientRect;
    switch (message)
    {
    case WM_CREATE:
        // Initialize for the OpenGL rendering
        hDeviceContext = GetDC(hWnd);
        if (!bSetupPixelFormat(hDeviceContext)) {
            MessageBox(hWnd, "Error in setting up pixel format for OpenGL", "Error", MB_OK | MB_ICONERROR);
            DestroyWindow(hWnd);
        }
        hRenderingContext = wglCreateContext(hDeviceContext);
        wglMakeCurrent(hDeviceContext, hRenderingContext);
        break;

    case WM_SIZE:
        GetClientRect(hWnd, &clientRect);
        Resize(clientRect.right, clientRect.bottom);
        InvalidateRect(hWnd, NULL, false);

        break;
        /*
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // 메뉴 선택을 구문 분석합니다:
            switch (wmId)
            {
            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);
                break;
            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;
        */
    case WM_PAINT:
    {
        DrawScene(hDeviceContext);
        ValidateRect(hWnd, NULL);

        /*
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: 여기에 hdc를 사용하는 그리기 코드를 추가합니다...
            EndPaint(hWnd, &ps);
            */
    }
    break;
    case WM_DESTROY:
        // Destroy all about OpenGL
        if (hRenderingContext)
            wglDeleteContext(hRenderingContext);
        if (hDeviceContext)
            ReleaseDC(hWnd, hDeviceContext);
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
```

## 속성
- 기하학적 primitve를 렌더링하는 방법을 결정하는 속성(물체들의 외형)
   - 컬러(points, lines, polygons)
   - 사이즈와 너비(points, lines)
   - 스티플 패턴(lines, polygons)
   - 폴리곤 모드(Polygon mode)

## POLYGON
- Loop로 닫혀 있지만, 내부가 있는 물체

```c++
glColor3f(1.0f, 0.0f, 0.0f);
glBegin(GL_POLYGON);
    glVertex2f(0, 0);
    glVertex2f(0, 100);
    glVertex2f(100, 100);
    glVertex2f(100, 0);
glEnd();
```

## POINTS
```c++
glPointSize(5.0f)
glBegin(GL_POINTS);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(200, 200);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 점 4개 출력
```

## LINES
```c++
glLineWidth(5.0f)
glBegin(GL_LINES);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 선 2개 출력
```

## LINE STRIP
```c++
glLineWidth(5.0f)
glBegin(GL_LINE_STRIP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 ㄷ 오른쪽으로 돌린 모양 출력
```

## LINE LOOP
```c++
glLineWidth(5.0f)
glBegin(GL_LINE_LOOP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd(); // 그라데이션 색상의 ㅁ 출력
```

## LINE STIPPLE
```c++
glEnable(GL_LINE_STIPPLE);
glLineWidth(5.0f)
glLineStipple(3, 0xcccc)
glBegin(GL_LINE_LOOP);
    glColor3f(1.0f, 0.0f, 0.0f);
    glVertex2f(100, 100);
    glColor3f(0.0f, 1.0f, 0.0f);
    glVertex2f(100, 200);
    glColor3f(0.0f, 0.0f, 1.0f);
    glVertex2f(200, 200);
    glColor3f(0.0f, 0.0f, 0.0f);
    glVertex2f(200, 100);
glEnd();
glDisable(GL_LINE_STIPPLE) // 펀칭되어있는 ㅁ 출력
```

## OpenGL 카메라
- -z 방향을 가리키는 세계공간의 원점에 카메라를 배치함
- 기본 관측 공간: 한 변의 길이가 2인 원점 중앙에 있는 상자

## 관측(Viewing)
- 투영 행렬에 의해 수행된다.
- 먼저, 행렬 모드를 설정 -> 단위 행렬 -> 투영 행렬

## 뷰포트(Viewports)
- 디스플레이 윈도우의 직사각형 영역
- 뷰 사각형과 윈도우 사각형의 종횡비가 일치하지 않아, 왜곡현상 발생 가능

## 종횡비 유지
```c++
void Resize(int width, int height)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glViewport(0, 0, width, height);

    if (width <= height)
        glOrtho(-2.0, 2.0, -2.0 * (GLfloat)height / (GLfloat)width,
            2.0 * (GLfloat)height / (GLfloat)width, 1.0, 10.0);

    else
        glOrtho(-2.0 * (GLfloat)width / (GLfloat)height,
            2.0 * (GLfloat)width / (GLfloat)height, -2.0, 2.0, 1.0, 10.0);

    return;

}
```

## 투영
- 3차원 객체가 2차원 객체로 변환되는 과정
- 투시 투영: glFrustum, gluPerspective(시야각 y축)
- 직교 투영: glOrtho