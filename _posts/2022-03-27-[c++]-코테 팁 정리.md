---
layout: post
category: Note
---

## 메모리 초과 시 확인하기

- in, cout 은 **ios_base::sync_with_stdio(false); cin.tie(0);** 등과 같은 처리를 해주지 않으면 매우 느린 연산. 이와 관해서는 cin, scanf 속도 차이 공부하기
  + 단, 이 코드를 사용하면 scanf, printf 사용 불가능!
- endl 은 최대한 사용하지 않는 것이 좋다. flush 를 계속 해주기 때문에 굉장히 느린 연산임. **"\n"** 을 사용하는 것이 훨씬 좋음.
  + endl은 명시적으로 플러시(출력 버퍼 비우기)가 발생하기 떄문임.
- unordered_set 과 같은 STL은 사용하지 않아도 될 때는 최대한 사용을 하지 않아야 함.

## C++ 체크하기

- 입력을 구성하는 각 원소 사이에 적어도 한 개의 공백 문자나 개행 문자가 존재할 경우에도 문제없이 작동함.
- 공백을 포함한 채로 읽어 들이는 프로그램 작성시 **getline 함수** 사용.
- 삼성 코테처럼 예제 파일일 경우

```c++
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
```
- 가장 많이 사용하는 정수 자료형은 32bit의 int지만, 수가 굉장히 클 경우 64bit 자료형인 long long 사용하기
  + 변수의 자료형은 long long인데 계산식의 포함된 수의 자료형이 모두 int일 경우 int값이 저장됨. 모두 long long으로 바꿔주기.

## 코드 짧게 만들기

- typedef을 이용해 자료형의 이름을 짧게 만들 수 있다.

```c++
typedef long long ll;

// long long a = 123456789;
// long long b = 987654321;
ll a = 123456789;
ll b = 987654321;

// typedef vector<int> vi;
// typedef pair<int, int> pi; <--- 이렇게도 사용 가능!
```
- 코드를 컴파일하기 전에 코드에 포함된 특정 문자열을 다른 문자열로 치환하기 = 매크로 사용

```c++
#define F first
#define S second
#define PB push_back
#define MP make_pair

// v.push_back(make_pair(y1,x1));
// v.push_back(make_pair(y2,x2));
// int d = v[i].first + v[i].second

v.PB(MP(y1, x1));
v.PB(MP(y2, x2));
int d = v[i].F+v[i].S;

// ----------------반복문과 구조문에서도 가능---------------------- //

#define REP(i,a,b) for (int i=a; i<=b; i++)

// for(int i=1; i<=n; i++){
//    search(i);
// }

REP(i, 1, n){
   search(i);
}
```


## 코테 볼 때

1. 지문 읽고 고민하기
   - 문제에 답이 있다.
   - 강조된 부분 잘 읽을 것.
   - **제약사항**을 보고 맞는 방법으로 접근하기.
   - 연산 어떻게 줄여야 할지 생각하기.
   - 최소 1시간 동안 고민하기.

2. 자료 구조 정하기
   - 동적 할당보다 메모리 풀이 나음
   - 메모리 크기 넘지 않게 변수 선언 stack과 heap 메모리 크기 주의
   - 가능하면 Heap, List로 풀기
   - Linked list 연결 에러 확인하기

3. 구현하기
   - 먼저 손코딩 하기(시험 시작하자마자 키보드에 손 얹지말기)
   - 설계가 완료되면 코드 작성

4. 최적화하기
   - 중요한 것은 시간 복잡도, 개선할 수 있는 logic 개선하기
   - tc 중에 가장 큰 걸로 돌려보기
   - 문제가 어려우면 어떻게든 풀고, 쉬우면 어떻게든 최적화

