---
layout: post
category: BOJ
---
> 2022년 1월부터 진행한 알고리즘 스터디의 기록장입니다. 모든 문제는 [자가비의 추천문제#1(zagabi)][zagabi]에서 셀렉 됐습니다!!

## Problem
미네크래프트에 있는 디디는 집을 짓기 위해 돌을 채취하려고 한다. N개의 바위들이 일렬로 놓여져 있고, 디디는 현재 첫 번째 바위에 위치해 있다. 각 바위 i는 서로 같거나 다른 강도를 가지고 있어서, 바위에서 돌을 채취하기 위해 해야 하는 곡괭이질의 수 Ki 또한 서로 같거나 다르다. 디디는 돌을 채취하기 위해 다음과 같은 행동을 할 수 있다.

1. 시간 1을 소비하여, 디디가 위치해 있는 바위에 곡괭이질을 1번 한다.
2. 시간 P를 소비하여, 이웃한 바위로 이동한다.

디디에게 T만큼의 시간이 주어졌을 때, 채취할 수 있는 돌의 최대 개수를 출력하는 프로그램을 작성하라.

## Input
첫째 줄에 정수 N(1 ≤ N ≤ 105), T(1 ≤ T ≤ 109), P(1 ≤ P ≤ 105)가 공백으로 구분되어 주어진다.
둘째 줄에 바위 i(i = 1, 2, ..., N)를 채취하기 위해 필요한 곡괭이질의 수 Ki(1 ≤ Ki ≤ 105)가 공백으로 구분되어 주어진다.

## Output
문제의 정답을 출력하라.

## Thought
돌을 캐는 것이 효율적일 때만 돌을 건들이고, 아니면 넘어가는 것이 좋다. 또한 돌을 채취하는 도중 다른 바위로 넘어가거나, 왼쪽으로 돌아간다는 등등의 행위는 버린다. 따라서 무조건 오른쪽으로 이동하되, 채취하기 위해 필요한 곡괭이질의 수가 많은 바위일 경우 넘어가야 한다. 현재 i번째 바위에 있다면, 남은 시간은 (T-i*P). 이 시간 내로 1~i번째 바위까지 필요 곡괭이질의 수가 적은 것들을 모두 채취하는 것이 적절하다.

#### Max Priority Queue
최대 우선순위 큐는 두 가지 연산을 지원한다.
- INSERT(x): 새로운 원소 x를 삽입
- EXTRACT_MAX(): 최댓값을 삭제하고 반환

우리는 관찰을 통해 다음과 같은 솔루션을 찾을 수 있다.
1. 1~N개의 바위를 Max Priority Queue에 (T-i*P)내로 캘 수 있는 것들을 하나씩 넣는다.
2. 하나씩 넣으면서, 총합이 해당 바위에서 사용할 수 있는 총 시간보다 크다면 삭제하고 넘어간다.
3. 이를 반복하면서, 최댓값을 찾는다. 

## Code
```c++
#include <bits/stdc++.h>
using namespace std;
int T,N,P,ans;

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    cin>>N>>T>>P;

    long long sum=0;
    priority_queue<int> pq;
    for(int i=0;i<N;i++){
        int cur;
        cin>>cur;
        sum+=cur;
        pq.emplace(cur);
        long long cnt=T-(long long)i*P;

        while(!pq.empty()&&sum>cnt){
            sum-=pq.top();
            pq.pop();
        }
        ans=max(ans,(int)pq.size());
    }
    cout<<ans;
}
```

[zagabi]: https://www.acmicpc.net/workbook/view/4344