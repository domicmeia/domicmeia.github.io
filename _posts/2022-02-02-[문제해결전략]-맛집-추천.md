---
layout: post
category: Algo
---
> `공부 목적`으로 작성한 포스팅입니다. 오타가 많고, 틀린 내용이 있을 수 있습니다.

## 목차
* [문제 설명]
* [문제 해결 전략]
  + [Subtask 3](#subtask-3)
  + [Subtask 5](#subtask-5)
  + [Subtask 7](#subtask-7)

---
{: data-content="start!"}

## Problem
KOI나라에는 N개의 도시가 있다. 각 도시에는 1번부터 N번까지의 번호가 붙어 있다. KOI나라는 구조가 특이해서, 도시를 정점으로 표현하고 길을 양방향 간선으로 표현하면 N개의 정점을 가진 트리가 된다. 트리는 사이클이 없는 연결 그래프이다. KOI나라에는 총 M개의 맛집이 있으며, 각 맛집에는 1번부터 M번까지의 번호가 붙어 있다. 맛집이 아예 없는 도시가 있을 수도 있고, 맛집이 두 개 이상 있는 도시가 있을 수도 있음에 유의하라.

- i (1 ≤ i ≤ M)번 맛집은 ci번 도시에 있으며, 배달 가능 거리는 di이고, 고객 선호도는 gi이다.
- i번 맛집은 ci번 도시에서부터 di개 이하의 길을 거쳐 갈 수 있는 도시들에만 배달을 할 수 있다. 즉, i번 맛집이 배달할 수 있는 도시들의 집합을 Ri라고 하면, Ri = {j\ d(ci, j) ≤ di}이다. 여기서 d(a, b)는 a번 도시와 b번 도시의 최단 경로의 길이(두 도시 사이를 이동하기 위해 거쳐야 하는 최소 길의 수)이다.

당신은 배달 앱의 운영자이다. 배달 앱은 맛집들을 추천하는데 서비스의 중복을 피하기 위해서 M개의 맛집 중 다음 조건을 만족하는 맛집들의 집합 S를 고르려고 한다.  
  
- 임의의 도시 p에 대해서, p는 S에 속하는 두 개 이상의 맛집의 배달 가능한 집합에 동시에 속하지 않는다. 즉, S에 속한 임의의 서로 다른 두 맛집 i와 j에 대해서, Ri ∩ Rj는 공집합이어야 한다.

위 조건을 만족하는 맛집들의 집합 S 중에서, S에 속한 맛집들의 선호도의 합이 최대인 집합을 찾아, 그 때 선호도의 합을 출력하는 프로그램을 작성하라.

## Input
첫 번째 줄에 두 개의 정수 N과 M이 공백 하나를 사이로 두고 주어진다.  
다음 N − 1개의 줄에는 KOI 나라의 길이 잇는 두 도시의 번호를 나타내는 정수 a와 b가 공백 하나를 사이로 두고 주어진다.  
다음 M개의 줄에는 맛집에 대한 정보가 주어진다. 이 중 i (1 ≤ i ≤ M)번째 줄에는 세 개의 정수 ci, di, gi가 공백 하나를 사이로 두고 주어진다.

## Output
첫 번째 줄에 문제의 조건을 만족하는 맛집의 집합 중 선호도의 합을 최대화하도록 집합을 골랐을 때의 선호도의 합을 출력한다.

## Constraints
- 주어지는 모든 수는 정수이다.
- 1 ≤ N ≤ 10^5
- 1 ≤ M ≤ 10^5
- 모든 i (1 ≤ i ≤ M)에 대해: 0 ≤ di ≤ N − 1, 1 ≤ gi ≤ 10^9

## Subtask

| 번호 | 배점 | 제한 |
| ---- | ---- | ---- |
| 1 | 9 | 1 ≤ i ≤ N − 1 에 대해서, i번 정점과 i + 1번 정점이 간선으로 연결되어 있다. |
| 2 | 11 | N, M ≤ 20 |
| 3 | 17 | N, M ≤ 2 000 |
| 4 | 10 | N ≤ 2 000 |
| 5 | 8 | 2 ≤ i ≤ N에 대해, ⌊i/2⌋번 정점과 i번 정점이 간선으로 연결되어 있다. |
| 6 | 12 | 차수가 3 이상인 정점은 많아야 하나뿐이다. |
| 7 | 33 | 추가 제약 조건이 없다. |

## Thought
m개의 정점(도시), 원(맛집), 가중치(선호도)  
중심은 *ci*, 반지름은 *di*, 선호도는 *gi*

## Subtask 3
동적계획법으로 풀이할 수 있다.  
선택된 모든 원들(*Ri*)이 v의 서브 트리 바깥으로 나가지 않고, 서로 겹치지 않을 때의 선호도 *MAX값*을 *Dv*로 정의할 때, 문제의 답은 *Droot*.

**v가 어떤 Ri에도 속하지 않을 때**  
즉, 어떤 원으로도 덮히지 않는 경우에는 *v*의 자식들에 대해서 구한 *dp*값을 합친 것들을 *Dv*로 정리해준다.

**v가 어떤 Ri에 속할 때 (단, v는 root가 아니다.)**  
*v*는 *Ri*가 덮는 원 중에서 가장 위쪽 점에 속해야 한다. 서브 트리 바깥으로 나가지 않았는데, *v*를 덮고 있기 때문이다. 즉, *v*가 원의 경계점에 속해야 한다.
*Dv*는 *Ri*의 중심 *ci*에서 *di*보다 정확히 한 칸 더 떨어진 정점들이라는 것을 알 수 있다. *Dv*는 가중치 *gi*와 *v*의 서브트리 중 *ci*와의 거리가 *di+1*인 정점들의 *D*값을 합해준 것과 같다.  

상태전이 한번에 필요한 식의 계수가 **O(N)**, 시간 복잡도가 **O(MN)**

## Subtask 5
트리가 완전 이진 트리 모양인 경우이다.  
이진트리는 트리의 깊이가 logn보다 크지 않다. 따라서 *dist(ci, x) = di + 1* 를 다음과 같이 logn개의 항으로 분해할 수 있다.
![dv](./image/dv.png)

여기서 F(v,d)를 v의 서브트리에서 거리가 v와 정확하게 d만큼 떨어져 있는 모든 Dx의 합이라 했을 때, 위의 식을 x에 관해 정리하면 다음과 같다.  
F(ci, di + 1) **+** F(P(ci), di) - F(ci, di -1) **+** ... = F(p^l(ci), di + 1 + l) - F(p^l-1(ci). di - l)

## Subtask 7
subtask 5의 풀이에 문제가 있다면, di가 n-1까지 늘어날 수 있기 때문에 항의 개수가 O(MN)이 되어서 시간 내에 구할 수 없다.

### Centroid Decomposition
트리에서 어떤 정점 *v*를 지웠을 때, 생긴 서브트리들의 최대 크기를 *maxsize(v)*라 하자.  
centroid는 *maxsize(v)*가 n/2 이하인 정점을 말한다.  
  
임의의 트리 T에는 항상 한 개 이상의 centroid가 존재하며, 최대 2개 까지 존재할 수 있다.[^1]  
반복적으로 센트로이드를 찾아서 트리를 분할하는 과정을 센트로이드 분할이라고 하고, 센트로이드의 정의상 총 O(NlogN) 시간에 수행할 수 있다.  
  
centroid decomposition을 트리에 적용하면 이진 트리 풀이의 문제점을 해결할 수 있다. 전체 트리의 centroid를 *C1*이라고 하면, 이를 제거했을 때 생성되는 서브트리에서 새로운 centroid인 *Ci*가 있을 것이다. 이렇게 만들어진 트리를 T*라고 부르자 
![dv2](./image/dv2.png)

- F*(v,d) = T*에서 v의 서브트리에 속하면서, dist(v,x) = d인 x의 DP 합
- G*(v,d) = T*에서 v의 서브트리에 속하면서, dist(π(v),x) = d인 x의 DP 합 

을 이용해 원하는 dp 값의 식을 구하면  
![dv3](./image/dv3.png)

사실 이 방법에서도 di의 값이 O(N)까지 늘어나지만, F*(v,d)가 0이 아닌 (v,d)의 개수는 T*의 서브트리의 개수에 비례하기 때문에 O(NlogN)개밖에 있을 수 없다.

## Code

```c++
#include <iostream>
#include <vector>
#include <array>
#include <tuple>
#include <cassert>
using namespace std;
using ll = long long;
using pii = pair<int,int>;
using ti = tuple<int,int,int>;

const int LG = 20;
int n, m;
vector<vector<int>> G; // N
vector<int> dep, ord; // N
vector<array<int,LG>> par; // N * logN
vector<int> pcen; // N

vector<vector<int>> RB;// N, Responsible Balls
vector<ti> BZ; // all balls
vector<vector<int>> B; // N, balls centered at x

struct hmap : vector<ll> {
    ll get(int x) {
        if(x < 0 || x >= int(size())) return 0ll;
        return *(begin()+x);
    }
    void add(int x, ll v) {
        if(x < 0 || x >= int(size())) {
            assert(0);
        }
        *(begin() + x) += v;
    }
};
vector<hmap> subdp, pardp;

namespace Cent {
    vector<int> sz; // N
    vector<bool> del; // N
    vector<int> vis; // N
    int vlk;
    void init() {
        sz.resize(n + 1);
        del.resize(n + 1);
        vis.resize(n + 1);
        vlk = 0;
    }
    void dfs(int x) {
        vis[x] = vlk;
        sz[x] = 1;
        for(int u : G[x]) {
            if(del[u] || vis[u] == vlk) continue;
            dfs(u);
            sz[x] += sz[u];
        }
    }

    int cen(int x, int tot) {
        pii msz(0, -1);
        for(int u : G[x]) {
            if(del[u] || vis[u] != vlk || sz[u] > sz[x]) continue;
            msz = max(msz, pii(sz[u], u));
        }
        if(msz.first * 2 <= tot) return x;
        return cen(msz.second, tot);
    }

    int dnc(int x) {
        ++vlk;
        dfs(x);
        int c = cen(x, sz[x]);
        subdp[c].resize(sz[x] + 1);
        pardp[c].resize(sz[x] + 1);
        del[c] = true;
        for(int u : G[c]) {
            if(del[u]) continue;
            int r = dnc(u);
            pcen[r] = c;
        }
        return c;
    }
}

vector<vector<int>> ballsToRetrieve; // N
vector<ll> dp; // N

int dfs_clk;
void dfs(int x) {
    ++dep[x];
    ord.push_back(x);
    for(int i = 1; i < LG; i++) par[x][i] = par[par[x][i-1]][i-1];
    for(int u : G[x]) {
        if(dep[u]) continue;
        dep[u] = dep[x]; par[u][0] = x;
        dfs(u);
    }
    for(auto j : B[x]) {
        ballsToRetrieve[max(1, dep[x] - get<1>(BZ[j]))].push_back(j);
    }
    RB[x] = ballsToRetrieve[ dep[x] ]; ballsToRetrieve[ dep[x] ].clear();
}

int lca(int i, int j) {
    if(dep[i] < dep[j]) swap(i, j);
    for(int a = dep[i] - dep[j], k = 0; a; a >>= 1, k++) {
        if(a & 1) i = par[i][k];
    }
    for(int l = 19; l >= 0; l--) {
        if(par[i][l] != par[j][l]) {
            i = par[i][l], j = par[j][l];
        }
    }
    return i == j ? i : par[i][0];
}

int dist(int i, int j) {
    int l = lca(i, j);
    return dep[i] + dep[j] - 2*dep[l];
}

ll collect_dp(int x, int d) {
    ll ans = 0;
    for(int v = x; v; v = pcen[v]) {
        int r = dist(v, x);
        ans += subdp[v].get(d - r);
        if(pcen[v]) {
            int s = dist(pcen[v], x);
            ans -= pardp[v].get(d - s);
        }
    }
    return ans;
}

void update_dp(int x, ll val) {
    for(int v = x; v; v = pcen[v]) {
        int r = dist(v, x);
        subdp[v].add(r, val);
        if(pcen[v]) {
            int s = dist(pcen[v], x);
            pardp[v].add(s, val);
        }
    }
}

void dfs_dp(int x) {
    for(int u : G[x]) {
        if(dep[u] < dep[x]) continue;
        dfs_dp(u);
        dp[x] += dp[u];
    }
    for(auto j : RB[x]) {
        auto [c, d, g] = BZ[j];
        ll local_dp = collect_dp(c, d+1);
        dp[x] = max(dp[x], g + local_dp);
    }
    update_dp(x, dp[x]);
}

void init() {
    G.resize(n + 1);
    dep.resize(n + 1);
    par.resize(n + 1);
    pcen.resize(n + 1);
    RB.resize(n + 1);
    B.resize(n + 1);
    ballsToRetrieve.resize(n + 1);
    subdp.resize(n + 1);
    pardp.resize(n + 1);
    dp.resize(n + 1);
    Cent::init();
}

int main(){
    ios_base::sync_with_stdio(false);cin.tie(nullptr);
    cin >> n >> m;
    init();

    for(int i = 1, a, b; i < n; i++) {
        cin >> a >> b;
        G[a].push_back(b);
        G[b].push_back(a);
    }
    Cent::dnc(1);
    for(int i = 0, c,d,g; i < m; i++) {
        cin >> c >> d >> g;
        BZ.emplace_back(c, d, g);
        B[c].push_back(i);
    }

    dfs(1);
    dfs_dp(1);
    cout << dp[1] << '\n';
}
```



---
{: data-content="footnotes"}

[^1]: 증명은 [여기][여기]를 참고


[여기]: http://www.secmem.org/blog/2021/04/14/centroid-of-a-tree/